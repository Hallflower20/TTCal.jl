{
    "docs": [
        {
            "location": "/", 
            "text": "TTCal\n\n\n\n\nTTCal is a calibration routine developed for the OVRO LWA.\n\n\nOverview\n\n\nThe standard procedure for phase calibrating a radio interferometer\nusually involves slewing a small number of large dishes to stare at\na known point source. A point source at the phase center of the\ninterferometer has zero phase on all baselines, so phase calibration\nessentially amounts to zeroing the phase on all baselines.\n\n\nLow frequency telescopes (\n300 MHz) tend to occupy an entirely different\nregion of phase space. That is they are usually composed of numerous\ncheap dipole antennas with very broad beams (\nLOFAR\n,\n\nMWA\n). Furthermore, the low frequency sky\nis corrupted by propagation through the ionosphere. Until the field matures,\nthe demand for a new and effective calibration technique\nis best met by a simple, adaptable, and relatively fast software package.\nThis is why I wrote TTCal.\n\n\nGetting Started\n\n\nTTCal requires version 0.4 of the \nJulia\n programming\nlanguage. Julia is a dynamic language designed for scientific computing with\na just-in-time compiler based on \nLLVM\n. The syntax\nshould be familiar to users of \nMatlab\n\nand \nPython\n, but Python users should be aware\nthat the first element of an array is accessed with \nx[1]\n.\n\n\nOnce Julia is installed, the REPL (read-eval-print loop) can be started by\ntyping \njulia\n from the command line. Try running the following examples:\n\n\njulia\n 1+1\n2\n\njulia\n for i = 1:3\n           println(rand())\n       end\n0.8165122957881887\n0.8315752097289137\n0.6558156424738537\n\n\n\n\nTTCal depends on the \nCasaCore.jl\n\npackage, which is a Julia wrapper of the \ncasacore\n\nlibrary. It is used to interface with measurement sets and perform\ncoordinate conversions.\n\n\nTo install TTCal, run:\n\n\n# Get the latest version of CasaCore.jl and build the wrapper\njulia\n Pkg.clone(\nCasaCore\n)\njulia\n Pkg.build(\nCasaCore\n)\n# Get the latest version of TTCal\njulia\n Pkg.clone(\nhttps://github.com/mweastwood/TTCal.jl.git\n)\njulia\n Pkg.update()\njulia\n Pkg.test(\nTTCal\n)\n\n\n\n\nIf all the tests pass, you are ready to begin using TTCal.\n\n\nWhile the most powerful interface to TTCal involves writing small\nJulia scripts, a limited command line interface is available.\nSimply add the \nttcal.jl\n file to your \nPATH\n environment variable.\nYou can see the list of available commands by running:\n\n\n$ ttcal.jl --help\nusage: ttcal.jl [-h] {gaincal|polcal|peel|applycal}\n\nA calibration routine developed for the OVRO LWA.\n\ncommands:\n  gaincal     Solve for a gain calibration.\n  polcal      Solve for a polarization calibration.\n  peel        Peel sources from the dataset.\n  applycal    Apply a calibration.\n\noptional arguments:\n  -h, --help  show this help message and exit\n\n\n\n\nNote that every time Julia is restarted there is overhead\nassociated with reloading and recompiling the code. While\nJulia version 0.4 introduced code caching to help mitigate this,\nrunning TTCal will always be faster from a Julia script\nthan from the command line.\n\n\nBugs\n\n\nIf you encounter any problems, please\n\nopen an issue\n\non Github.\n\n\nKnown problems are listed as\n\nopen issues\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#ttcal", 
            "text": "TTCal is a calibration routine developed for the OVRO LWA.", 
            "title": "TTCal"
        }, 
        {
            "location": "/#overview", 
            "text": "The standard procedure for phase calibrating a radio interferometer\nusually involves slewing a small number of large dishes to stare at\na known point source. A point source at the phase center of the\ninterferometer has zero phase on all baselines, so phase calibration\nessentially amounts to zeroing the phase on all baselines.  Low frequency telescopes ( 300 MHz) tend to occupy an entirely different\nregion of phase space. That is they are usually composed of numerous\ncheap dipole antennas with very broad beams ( LOFAR , MWA ). Furthermore, the low frequency sky\nis corrupted by propagation through the ionosphere. Until the field matures,\nthe demand for a new and effective calibration technique\nis best met by a simple, adaptable, and relatively fast software package.\nThis is why I wrote TTCal.", 
            "title": "Overview"
        }, 
        {
            "location": "/#getting-started", 
            "text": "TTCal requires version 0.4 of the  Julia  programming\nlanguage. Julia is a dynamic language designed for scientific computing with\na just-in-time compiler based on  LLVM . The syntax\nshould be familiar to users of  Matlab \nand  Python , but Python users should be aware\nthat the first element of an array is accessed with  x[1] .  Once Julia is installed, the REPL (read-eval-print loop) can be started by\ntyping  julia  from the command line. Try running the following examples:  julia  1+1\n2\n\njulia  for i = 1:3\n           println(rand())\n       end\n0.8165122957881887\n0.8315752097289137\n0.6558156424738537  TTCal depends on the  CasaCore.jl \npackage, which is a Julia wrapper of the  casacore \nlibrary. It is used to interface with measurement sets and perform\ncoordinate conversions.  To install TTCal, run:  # Get the latest version of CasaCore.jl and build the wrapper\njulia  Pkg.clone( CasaCore )\njulia  Pkg.build( CasaCore )\n# Get the latest version of TTCal\njulia  Pkg.clone( https://github.com/mweastwood/TTCal.jl.git )\njulia  Pkg.update()\njulia  Pkg.test( TTCal )  If all the tests pass, you are ready to begin using TTCal.  While the most powerful interface to TTCal involves writing small\nJulia scripts, a limited command line interface is available.\nSimply add the  ttcal.jl  file to your  PATH  environment variable.\nYou can see the list of available commands by running:  $ ttcal.jl --help\nusage: ttcal.jl [-h] {gaincal|polcal|peel|applycal}\n\nA calibration routine developed for the OVRO LWA.\n\ncommands:\n  gaincal     Solve for a gain calibration.\n  polcal      Solve for a polarization calibration.\n  peel        Peel sources from the dataset.\n  applycal    Apply a calibration.\n\noptional arguments:\n  -h, --help  show this help message and exit  Note that every time Julia is restarted there is overhead\nassociated with reloading and recompiling the code. While\nJulia version 0.4 introduced code caching to help mitigate this,\nrunning TTCal will always be faster from a Julia script\nthan from the command line.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#bugs", 
            "text": "If you encounter any problems, please open an issue \non Github.  Known problems are listed as open issues .", 
            "title": "Bugs"
        }, 
        {
            "location": "/gaincal/", 
            "text": "Gain Calibration\n\n\nWith this calibration TTCal will solve for one complex gain (amplitude and phase)\nper antenna polarization per frequency channel. That is for complex $g_i$ and\n$i$, $j$ labeling the pair of antennas composing the baseline, TTCal seeks to minimize\n\n\n\n\n\n    \\sum_{i,j} \\left\\| V_{i,j} - g_i g_j^* M_{i,j} \\right\\|^2\n\n\n\n\n\nwhere $V_{i,j}$ is the measured visibility and $M_{i,j}$ is the model visibility\nmeasured on the baseline $i$, $j$.\n\n\nTTCal uses the iterative routine independently described by\n\nMitchell et al. 2008\n and\n\nSalvini \n Wijnholds 2014\n\nto solve for the complex gains.\n\n\nFor more information on defining a sky model see \nSky Models\n.\n\n\nTTCal will flag frequency channels that do not converge within the specified maximum\nnumber of iterations. However, TTCal will not attempt to identify bad antennas\nthat may be poisoning the calibration. These antennas must be flagged ahead of\ntime.\n\n\nTTCal assumes that the measurement set contains all baselines, multiple\nfrequency channels, but only a single integration.\n\n\nRunning from a Julia script\n\n\nusing TTCal\nms      = MeasurementSet(\ndata.ms\n)\nsources = readsources(\nsources.json\n)\nbeam    = TTCal.SineBeam()\ncal = gaincal(ms, sources, beam, maxiter = 20, tolerance = 1e-3)\napplycal!(ms, cal, force_imaging_columns = true)\nunlock(ms)\n\n\n\n\nRunning from the command line\n\n\nFor a list of all available options, run:\n\n\nttcal.jl gaincal --help\n\n\n\n\nTo calibrate a standard OVRO LWA dataset:\n\n\nttcal.jl gaincal --input data.ms --output calibration.jld --sources sources.json\nttcal.jl applycal --input data.ms --calibration calibration.jld", 
            "title": "Gain Calibration"
        }, 
        {
            "location": "/gaincal/#gain-calibration", 
            "text": "With this calibration TTCal will solve for one complex gain (amplitude and phase)\nper antenna polarization per frequency channel. That is for complex $g_i$ and\n$i$, $j$ labeling the pair of antennas composing the baseline, TTCal seeks to minimize   \n    \\sum_{i,j} \\left\\| V_{i,j} - g_i g_j^* M_{i,j} \\right\\|^2   where $V_{i,j}$ is the measured visibility and $M_{i,j}$ is the model visibility\nmeasured on the baseline $i$, $j$.  TTCal uses the iterative routine independently described by Mitchell et al. 2008  and Salvini   Wijnholds 2014 \nto solve for the complex gains.  For more information on defining a sky model see  Sky Models .  TTCal will flag frequency channels that do not converge within the specified maximum\nnumber of iterations. However, TTCal will not attempt to identify bad antennas\nthat may be poisoning the calibration. These antennas must be flagged ahead of\ntime.  TTCal assumes that the measurement set contains all baselines, multiple\nfrequency channels, but only a single integration.  Running from a Julia script  using TTCal\nms      = MeasurementSet( data.ms )\nsources = readsources( sources.json )\nbeam    = TTCal.SineBeam()\ncal = gaincal(ms, sources, beam, maxiter = 20, tolerance = 1e-3)\napplycal!(ms, cal, force_imaging_columns = true)\nunlock(ms)  Running from the command line  For a list of all available options, run:  ttcal.jl gaincal --help  To calibrate a standard OVRO LWA dataset:  ttcal.jl gaincal --input data.ms --output calibration.jld --sources sources.json\nttcal.jl applycal --input data.ms --calibration calibration.jld", 
            "title": "Gain Calibration"
        }, 
        {
            "location": "/polcal/", 
            "text": "", 
            "title": "Polarization Calibration"
        }, 
        {
            "location": "/ampcal/", 
            "text": "", 
            "title": "Amplitude Calibration"
        }, 
        {
            "location": "/sources/", 
            "text": "Sky Models\n\n\nPoint Sources\n\n\nFor the OVRO LWA, the two most important point sources for calibration are\n\nCas A\n and\n\nCyg A\n, which are the two brightest\nsources on the sky. The optimal time to solve for a calibration is when both\nof these sources are above the horizon.\n\n\nCurrently TTCal expects the sky model to be specified as a list of point sources.\nThis is accomplished by listing the sources in a \nJSON\n file.\nFor example, the following file defines a sky model consisting of Cas A and Cyg A\nusing the published spectra for \nBaars et al. 1977\n.\n\n\n[\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCas A\n,\n        \nra\n: \n23h23m24s\n,\n        \ndec\n: \n58d48m54s\n,\n        \nI\n: 555904.26,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [-0.770]\n    },\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCyg A\n,\n        \nra\n: \n19h59m28.35663s\n,\n        \ndec\n: \n+40d44m02.0970s\n,\n        \nI\n: 49545.02,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [+0.085,-0.178]\n    }\n]\n\n\n\n\nFields:\n\n\n\n\nref\n is not used by TTCal, but is intended to be a record of the origin\n  of the information used to define the source.\n\n\nname\n is the name of the source.\n\n\nra\n and \ndec\n define the J2000 location of the source.\n\n\nI\n, \nQ\n, \nU\n, and \nV\n define the Stokes parameters (in Jy) at the frequency \nfreq\n (in Hz).\n\n\nindex\n defines the spectral index of the source.\n\n\n\n\nHigher order terms are defined such that\n\n\n    \\log S = \\log S_0 + \\sum_{n=1}^N \\alpha_n \\log\\left(\\frac{\\nu}{\\nu_0}\\right)^n\n\n\nwhere $S$ is the value of a given Stokes parameter and $\\alpha_n$ represents\nthe values contained in \nindex\n.\n\n\nDiffuse Emission\n\n\nDiffuse emission is currently not supported within TTCal. Eventual support is on the\nhorizon.", 
            "title": "Sky Models"
        }, 
        {
            "location": "/sources/#sky-models", 
            "text": "Point Sources  For the OVRO LWA, the two most important point sources for calibration are Cas A  and Cyg A , which are the two brightest\nsources on the sky. The optimal time to solve for a calibration is when both\nof these sources are above the horizon.  Currently TTCal expects the sky model to be specified as a list of point sources.\nThis is accomplished by listing the sources in a  JSON  file.\nFor example, the following file defines a sky model consisting of Cas A and Cyg A\nusing the published spectra for  Baars et al. 1977 .  [\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cas A ,\n         ra :  23h23m24s ,\n         dec :  58d48m54s ,\n         I : 555904.26,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [-0.770]\n    },\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cyg A ,\n         ra :  19h59m28.35663s ,\n         dec :  +40d44m02.0970s ,\n         I : 49545.02,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [+0.085,-0.178]\n    }\n]  Fields:   ref  is not used by TTCal, but is intended to be a record of the origin\n  of the information used to define the source.  name  is the name of the source.  ra  and  dec  define the J2000 location of the source.  I ,  Q ,  U , and  V  define the Stokes parameters (in Jy) at the frequency  freq  (in Hz).  index  defines the spectral index of the source.   Higher order terms are defined such that \n    \\log S = \\log S_0 + \\sum_{n=1}^N \\alpha_n \\log\\left(\\frac{\\nu}{\\nu_0}\\right)^n \nwhere $S$ is the value of a given Stokes parameter and $\\alpha_n$ represents\nthe values contained in  index .  Diffuse Emission  Diffuse emission is currently not supported within TTCal. Eventual support is on the\nhorizon.", 
            "title": "Sky Models"
        }, 
        {
            "location": "/api/", 
            "text": "AmplitudeCalibration\n\n\nAmplitudeCalibration \n: Calibration\n\n\n\n\nThis type stores the information for calibrating only the amplitude of the electronic gains. It stores the gain amplitudes and flags for each antenna, frequency channel, and polarization.\n\n\nAmplitudeCalibration(Nant,Nfreq)\n\n\n\n\nCreate a calibration table for \nNant\n antennas with \nNfreq\n frequency channels where all the amplitudes are initially set to unity.\n\n\nGainCalibration\n\n\nGainCalibration \n: Calibration\n\n\n\n\nThis type stores the information for calibrating the electronic gains of the interferometer. That is, it stores complex gains and flags for each antenna, frequency channel, and polarization.\n\n\nGainCalibration(Nant,Nfreq)\n\n\n\n\nCreate a calibration table for \nNant\n antennas with \nNfreq\n frequency channels where all the gains are initially set to unity.\n\n\nMeasurementSet\n\n\nimmutable MeasurementSet\n\n\n\n\nThis type is a wrapper around \nCasaCore.Tables.Table\n that is intended to simplify most of the common interactions between TTCal and measurement sets.\n\n\nMeasurementSet(name)\n\n\n\n\nOpen the measurement set at the given location. Assorted quantities that are commonly used by TTCal are automatically loaded and stored in fields.\n\n\nPointSource\n\n\ntype PointSource\n\n\n\n\nThese sources have a multi-component power-law spectrum such that:\n\n\nlog(flux) = log(I) + index[1]*log(\u03bd/reffreq)\n                   + index[2]*log\u00b2(\u03bd/reffreq) + ...\n\n\n\n\nPolarized fluxes are obtained in a similar manner by substituting Q/U/V for I in the above expression.\n\n\nPolarizationCalibration\n\n\nPolarizationCalibration \n: Calibration\n\n\n\n\nThis type stores the information for calibrating the polarization of the interferometer. That is, it stores Jones matrices and flags for each antenna and each frequency channel.\n\n\nPolarizationCalibration(Nant,Nfreq)\n\n\n\n\nCreate a calibration table for \nNant\n antennas with \nNfreq\n frequency channels where all the Jones matrices are initially set to the identity matrix.\n\n\nampcal\n\n\nampcal(ms::MeasurementSet,\n       sources::Vector{PointSource},\n       beam::BeamModel;\n       maxiter = 30, tolerance = 1e-3,\n       force_imaging_columns = false)\n\n\n\n\nSolve for the amplitude of the interferometer's gains.\n\n\napplycal!\n\n\nApply the calibration to the given measurement set.\n\n\ncorrupt!\n\n\nCorrupt the model data as if it had been observed with an instrument with the given calibration.\n\n\nfitvis\n\n\nfitvis(ms::MeasurementSet,\n       sources::Vector{PointSource};\n       maxiter::Int = 20,\n       tolerance::Float64 = 1e-3,\n       minuvw::Float64 = 0.0)\n\n\n\n\nFit for the location of each point source.\n\n\ngaincal\n\n\ngaincal(ms::MeasurementSet,\n        sources::Vector{PointSource},\n        beam::BeamModel;\n        maxiter = 20, tolerance = 1e-5,\n        force_imaging_columns = false,\n        reference_antenna = 1)\n\n\n\n\nSolve for the interferometer's electronic gains.\n\n\ngenvis\n\n\ngenvis(ms::MeasurementSet,\n       sources::Union{PointSource,Vector{PointSource}},\n       beam::BeamModel)\n\n\n\n\nGenerate model visibilities for the given list of sources and the given beam model.\n\n\nNo gridding is performed, so the runtime of this naive algorithm scales as $O(N_{base} \\times N_{source})$.\n\n\ngetspec\n\n\ngetspec(ms::MeasurementSet, dir::Direction) -\n xx,xy,yx,yy\n\n\n\n\nThis function extracts the spectrum in a given direction by means of an inverse discrete Fourier transform.\n\n\nNote that no gridding is performed, so this does \nnot\n use a fast Fourier transform. However, the inverse discrete Fourier transform \nis\n the least squares estimator for the flux in a given direction (if all baselines are weighted equally).\n\n\ngetspec(data, flags, l, m, u, v, w, \u03bd, ant1, ant2) -\n xx,xy,yx,yy\n\n\n\n\nCompute the spectrum of a source located at $(l,m)$ in all of the polarized correlation products.\n\n\npeel!\n\n\npeel!{T\n:Calibration}(::Type{T},\n                      ms::MeasurementSet,\n                      sources::Vector{PointSource},\n                      beam::BeamModel;\n                      maxiter = 20,\n                      tolerance = 1e-3,\n                      minuvw = 0.0)\n\n\n\n\nPeel the given list of sources from the measurement set.\n\n\nThe type supplied as the first argument determines the manner in which the sources are peeled:\n\n\n\n\nPolarizationCalibration\n - each source receives a full set of Jones matrices\n\n\nGainCalibration\n - each source receives a full set of complex gains\n\n\nAmplitudeCalibration\n - each source receives a full set of gain amplitudes\n\n\n\n\npolcal\n\n\npolcal(ms::MeasurementSet,\n       sources::Vector{PointSources},\n       beam::BeamModel;\n       maxiter = 20, tolerance = 1e-5,\n       force_imaging_columns = false)\n\n\n\n\nSolve for the polarization properties of the interferometer.\n\n\nreadsources\n\n\nsubsrc!\n\n\nsubsrc!(ms::MeasurementSet, dir::Direction)\n\n\n\n\nSubtract all of the measured flux from a given direction.\n\n\nThis can be used to remove RFI sources provided they have a known direction.\n\n\nsubsrc!(ms::MeasurementSet,\n        sources::Vector{PointSource},\n        beam::BeamModel)\n\n\n\n\nRemove the list of sources from the measurement set.\n\n\nwritesources", 
            "title": "API"
        }, 
        {
            "location": "/api/#amplitudecalibration", 
            "text": "AmplitudeCalibration  : Calibration  This type stores the information for calibrating only the amplitude of the electronic gains. It stores the gain amplitudes and flags for each antenna, frequency channel, and polarization.  AmplitudeCalibration(Nant,Nfreq)  Create a calibration table for  Nant  antennas with  Nfreq  frequency channels where all the amplitudes are initially set to unity.", 
            "title": "AmplitudeCalibration"
        }, 
        {
            "location": "/api/#gaincalibration", 
            "text": "GainCalibration  : Calibration  This type stores the information for calibrating the electronic gains of the interferometer. That is, it stores complex gains and flags for each antenna, frequency channel, and polarization.  GainCalibration(Nant,Nfreq)  Create a calibration table for  Nant  antennas with  Nfreq  frequency channels where all the gains are initially set to unity.", 
            "title": "GainCalibration"
        }, 
        {
            "location": "/api/#measurementset", 
            "text": "immutable MeasurementSet  This type is a wrapper around  CasaCore.Tables.Table  that is intended to simplify most of the common interactions between TTCal and measurement sets.  MeasurementSet(name)  Open the measurement set at the given location. Assorted quantities that are commonly used by TTCal are automatically loaded and stored in fields.", 
            "title": "MeasurementSet"
        }, 
        {
            "location": "/api/#pointsource", 
            "text": "type PointSource  These sources have a multi-component power-law spectrum such that:  log(flux) = log(I) + index[1]*log(\u03bd/reffreq)\n                   + index[2]*log\u00b2(\u03bd/reffreq) + ...  Polarized fluxes are obtained in a similar manner by substituting Q/U/V for I in the above expression.", 
            "title": "PointSource"
        }, 
        {
            "location": "/api/#polarizationcalibration", 
            "text": "PolarizationCalibration  : Calibration  This type stores the information for calibrating the polarization of the interferometer. That is, it stores Jones matrices and flags for each antenna and each frequency channel.  PolarizationCalibration(Nant,Nfreq)  Create a calibration table for  Nant  antennas with  Nfreq  frequency channels where all the Jones matrices are initially set to the identity matrix.", 
            "title": "PolarizationCalibration"
        }, 
        {
            "location": "/api/#ampcal", 
            "text": "ampcal(ms::MeasurementSet,\n       sources::Vector{PointSource},\n       beam::BeamModel;\n       maxiter = 30, tolerance = 1e-3,\n       force_imaging_columns = false)  Solve for the amplitude of the interferometer's gains.", 
            "title": "ampcal"
        }, 
        {
            "location": "/api/#applycal", 
            "text": "Apply the calibration to the given measurement set.", 
            "title": "applycal!"
        }, 
        {
            "location": "/api/#corrupt", 
            "text": "Corrupt the model data as if it had been observed with an instrument with the given calibration.", 
            "title": "corrupt!"
        }, 
        {
            "location": "/api/#fitvis", 
            "text": "fitvis(ms::MeasurementSet,\n       sources::Vector{PointSource};\n       maxiter::Int = 20,\n       tolerance::Float64 = 1e-3,\n       minuvw::Float64 = 0.0)  Fit for the location of each point source.", 
            "title": "fitvis"
        }, 
        {
            "location": "/api/#gaincal", 
            "text": "gaincal(ms::MeasurementSet,\n        sources::Vector{PointSource},\n        beam::BeamModel;\n        maxiter = 20, tolerance = 1e-5,\n        force_imaging_columns = false,\n        reference_antenna = 1)  Solve for the interferometer's electronic gains.", 
            "title": "gaincal"
        }, 
        {
            "location": "/api/#genvis", 
            "text": "genvis(ms::MeasurementSet,\n       sources::Union{PointSource,Vector{PointSource}},\n       beam::BeamModel)  Generate model visibilities for the given list of sources and the given beam model.  No gridding is performed, so the runtime of this naive algorithm scales as $O(N_{base} \\times N_{source})$.", 
            "title": "genvis"
        }, 
        {
            "location": "/api/#getspec", 
            "text": "getspec(ms::MeasurementSet, dir::Direction) -  xx,xy,yx,yy  This function extracts the spectrum in a given direction by means of an inverse discrete Fourier transform.  Note that no gridding is performed, so this does  not  use a fast Fourier transform. However, the inverse discrete Fourier transform  is  the least squares estimator for the flux in a given direction (if all baselines are weighted equally).  getspec(data, flags, l, m, u, v, w, \u03bd, ant1, ant2) -  xx,xy,yx,yy  Compute the spectrum of a source located at $(l,m)$ in all of the polarized correlation products.", 
            "title": "getspec"
        }, 
        {
            "location": "/api/#peel", 
            "text": "peel!{T :Calibration}(::Type{T},\n                      ms::MeasurementSet,\n                      sources::Vector{PointSource},\n                      beam::BeamModel;\n                      maxiter = 20,\n                      tolerance = 1e-3,\n                      minuvw = 0.0)  Peel the given list of sources from the measurement set.  The type supplied as the first argument determines the manner in which the sources are peeled:   PolarizationCalibration  - each source receives a full set of Jones matrices  GainCalibration  - each source receives a full set of complex gains  AmplitudeCalibration  - each source receives a full set of gain amplitudes", 
            "title": "peel!"
        }, 
        {
            "location": "/api/#polcal", 
            "text": "polcal(ms::MeasurementSet,\n       sources::Vector{PointSources},\n       beam::BeamModel;\n       maxiter = 20, tolerance = 1e-5,\n       force_imaging_columns = false)  Solve for the polarization properties of the interferometer.", 
            "title": "polcal"
        }, 
        {
            "location": "/api/#readsources", 
            "text": "", 
            "title": "readsources"
        }, 
        {
            "location": "/api/#subsrc", 
            "text": "subsrc!(ms::MeasurementSet, dir::Direction)  Subtract all of the measured flux from a given direction.  This can be used to remove RFI sources provided they have a known direction.  subsrc!(ms::MeasurementSet,\n        sources::Vector{PointSource},\n        beam::BeamModel)  Remove the list of sources from the measurement set.", 
            "title": "subsrc!"
        }, 
        {
            "location": "/api/#writesources", 
            "text": "", 
            "title": "writesources"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "", 
            "title": "Contributing"
        }, 
        {
            "location": "/docs/", 
            "text": "Building this Website\n\n\nThis website is built using \nMkDocs\n and hosted\non \nGithub Pages\n. Building and deploying the\ndocumentation will require a little bit of setup.\n\n\n\n\nRun \npip install --user mkdocs\n to obtain MkDocs.\n\n\nRun \npip install --user python-markdown-math\n to obtain the markdown\n   extension that allows LaTeX-style math.\n\n\nRun \ndocs/gendocs.jl\n to extract the documentation from the Julia\n   source code into the relevant Markdown files.\n\n\nRun \nmkdocs serve\n and navigate your web browser to\n   \nhttp://127.0.0.1:8000\n\n   to check that everything looks correct.\n\n\nRun \nmkdocs gh-deploy\n to deploy the new documentation to Github Pages.\n\n\nCommit all your changes.", 
            "title": "Building this Website"
        }, 
        {
            "location": "/docs/#building-this-website", 
            "text": "This website is built using  MkDocs  and hosted\non  Github Pages . Building and deploying the\ndocumentation will require a little bit of setup.   Run  pip install --user mkdocs  to obtain MkDocs.  Run  pip install --user python-markdown-math  to obtain the markdown\n   extension that allows LaTeX-style math.  Run  docs/gendocs.jl  to extract the documentation from the Julia\n   source code into the relevant Markdown files.  Run  mkdocs serve  and navigate your web browser to\n    http://127.0.0.1:8000 \n   to check that everything looks correct.  Run  mkdocs gh-deploy  to deploy the new documentation to Github Pages.  Commit all your changes.", 
            "title": "Building this Website"
        }
    ]
}