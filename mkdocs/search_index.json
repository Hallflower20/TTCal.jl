{
    "docs": [
        {
            "location": "/", 
            "text": "TTCal\n\n\n\n\nTTCal is a calibration routine developed for the OVRO LWA.\n\n\nOverview\n\n\nThe standard procedure for phase calibrating a radio interferometer\nusually involves slewing a small number of large dishes to stare at\na known point source. A point source at the phase center of the\ninterferometer has zero phase on all baselines, so phase calibration\nessentially amounts to zeroing the phase on all baselines.\n\n\nLow frequency telescopes (\n300 MHz) tend to occupy an entirely different\nregion of phase space. That is they are usually composed of numerous\ncheap dipole antennas with very broad beams (\nLOFAR\n,\n\nMWA\n). Furthermore, the low frequency sky\nis corrupted by propagation through the ionosphere. Until the field matures,\nthe demand for a new and effective calibration technique\nis best met by a simple, adaptable, and relatively fast software package.\nThis is why I wrote TTCal.\n\n\nGetting Started\n\n\nTTCal requires version 0.4 of the \nJulia\n programming\nlanguage. Julia is a dynamic language designed for scientific computing with\na just-in-time compiler based on \nLLVM\n. The syntax\nshould be familiar to users of \nMatlab\n\nand \nPython\n, but Python users should be aware\nthat the first element of an array is accessed with \nx[1]\n.\n\n\nOnce Julia is installed, the REPL (read-eval-print loop) can be started by\ntyping \njulia\n from the command line. Try running the following examples:\n\n\njulia\n 1+1\n2\n\njulia\n for i = 1:3\n           println(rand())\n       end\n0.8165122957881887\n0.8315752097289137\n0.6558156424738537\n\n\n\n\nTTCal depends on the \nCasaCore.jl\n\npackage, which is a Julia wrapper of the \ncasacore\n\nlibrary. It is used to interface with measurement sets and perform\ncoordinate conversions.\n\n\nTo install TTCal, run:\n\n\n# Get the latest version of CasaCore.jl and build the wrapper\njulia\n Pkg.clone(\nCasaCore\n)\njulia\n Pkg.build(\nCasaCore\n)\n# Get the latest version of TTCal\njulia\n Pkg.clone(\nhttps://github.com/mweastwood/TTCal.jl.git\n)\njulia\n Pkg.update()\njulia\n Pkg.test(\nTTCal\n)\n\n\n\n\nIf all the tests pass, you are ready to begin using TTCal.\n\n\nWhile the most powerful interface to TTCal involves writing small\nJulia scripts, a limited command line interface is available.\nSimply add the \nttcal.jl\n file to your \nPATH\n environment variable.\nYou can see the list of available commands by running:\n\n\n$ ttcal.jl --help\nusage: ttcal.jl [-h] {gaincal|polcal|peel|applycal}\n\nA calibration routine developed for the OVRO LWA.\n\ncommands:\n  gaincal     Solve for a gain calibration.\n  polcal      Solve for a polarization calibration.\n  peel        Peel sources from the dataset.\n  applycal    Apply a calibration.\n\noptional arguments:\n  -h, --help  show this help message and exit\n\n\n\n\nNote that every time Julia is restarted there is overhead\nassociated with reloading and recompiling the code. While\nJulia version 0.4 introduced code caching to help mitigate this,\nrunning TTCal will always be faster from a Julia script\nthan from the command line.\n\n\nBugs\n\n\nIf you encounter any problems, please\n\nopen an issue\n\non Github.\n\n\nKnown problems are listed as\n\nopen issues\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#ttcal", 
            "text": "TTCal is a calibration routine developed for the OVRO LWA.", 
            "title": "TTCal"
        }, 
        {
            "location": "/#overview", 
            "text": "The standard procedure for phase calibrating a radio interferometer\nusually involves slewing a small number of large dishes to stare at\na known point source. A point source at the phase center of the\ninterferometer has zero phase on all baselines, so phase calibration\nessentially amounts to zeroing the phase on all baselines.  Low frequency telescopes ( 300 MHz) tend to occupy an entirely different\nregion of phase space. That is they are usually composed of numerous\ncheap dipole antennas with very broad beams ( LOFAR , MWA ). Furthermore, the low frequency sky\nis corrupted by propagation through the ionosphere. Until the field matures,\nthe demand for a new and effective calibration technique\nis best met by a simple, adaptable, and relatively fast software package.\nThis is why I wrote TTCal.", 
            "title": "Overview"
        }, 
        {
            "location": "/#getting-started", 
            "text": "TTCal requires version 0.4 of the  Julia  programming\nlanguage. Julia is a dynamic language designed for scientific computing with\na just-in-time compiler based on  LLVM . The syntax\nshould be familiar to users of  Matlab \nand  Python , but Python users should be aware\nthat the first element of an array is accessed with  x[1] .  Once Julia is installed, the REPL (read-eval-print loop) can be started by\ntyping  julia  from the command line. Try running the following examples:  julia  1+1\n2\n\njulia  for i = 1:3\n           println(rand())\n       end\n0.8165122957881887\n0.8315752097289137\n0.6558156424738537  TTCal depends on the  CasaCore.jl \npackage, which is a Julia wrapper of the  casacore \nlibrary. It is used to interface with measurement sets and perform\ncoordinate conversions.  To install TTCal, run:  # Get the latest version of CasaCore.jl and build the wrapper\njulia  Pkg.clone( CasaCore )\njulia  Pkg.build( CasaCore )\n# Get the latest version of TTCal\njulia  Pkg.clone( https://github.com/mweastwood/TTCal.jl.git )\njulia  Pkg.update()\njulia  Pkg.test( TTCal )  If all the tests pass, you are ready to begin using TTCal.  While the most powerful interface to TTCal involves writing small\nJulia scripts, a limited command line interface is available.\nSimply add the  ttcal.jl  file to your  PATH  environment variable.\nYou can see the list of available commands by running:  $ ttcal.jl --help\nusage: ttcal.jl [-h] {gaincal|polcal|peel|applycal}\n\nA calibration routine developed for the OVRO LWA.\n\ncommands:\n  gaincal     Solve for a gain calibration.\n  polcal      Solve for a polarization calibration.\n  peel        Peel sources from the dataset.\n  applycal    Apply a calibration.\n\noptional arguments:\n  -h, --help  show this help message and exit  Note that every time Julia is restarted there is overhead\nassociated with reloading and recompiling the code. While\nJulia version 0.4 introduced code caching to help mitigate this,\nrunning TTCal will always be faster from a Julia script\nthan from the command line.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#bugs", 
            "text": "If you encounter any problems, please open an issue \non Github.  Known problems are listed as open issues .", 
            "title": "Bugs"
        }, 
        {
            "location": "/gaincal/", 
            "text": "Gain Calibration\n\n\nWith this calibration TTCal will solve for one complex gain (amplitude and phase)\nper antenna polarization per frequency channel. That is for complex $g_i$ and\n$i$, $j$ labeling the pair of antennas composing the baseline, TTCal seeks to minimize\n\n\n\n\n\n    \\sum_{i,j} \\left\\| V_{i,j} - g_i g_j^* M_{i,j} \\right\\|^2\n\n\n\n\n\nwhere $V_{i,j}$ is the measured visibility and $M_{i,j}$ is the model visibility\nmeasured on the baseline $i$, $j$.\n\n\nTTCal uses the iterative routine independently described by\n\nMitchell et al. 2008\n and\n\nSalvini \n Wijnholds 2014\n\nto solve for the complex gains.\n\n\nFor more information on defining a sky model see \nSky Models\n.\n\n\nTTCal will flag frequency channels that do not converge within the specified maximum\nnumber of iterations. However, TTCal will not attempt to identify bad antennas\nthat may be poisoning the calibration. These antennas must be flagged ahead of\ntime.\n\n\nTTCal assumes that the measurement set contains all baselines, multiple\nfrequency channels, but only a single integration.\n\n\nRunning from a Julia script\n\n\nusing TTCal\nms      = MeasurementSet(\ndata.ms\n)\nsources = readsources(\nsources.json\n)\nbeam    = TTCal.SineBeam()\ncal = gaincal(ms, sources, beam, maxiter = 20, tolerance = 1e-3)\napplycal!(ms, cal, force_imaging_columns = true)\nunlock(ms)\n\n\n\n\nRunning from the command line\n\n\nFor a list of all available options, run:\n\n\nttcal.jl gaincal --help\n\n\n\n\nTo calibrate a standard OVRO LWA dataset:\n\n\nttcal.jl gaincal --input data.ms --output calibration.jld --sources sources.json\nttcal.jl applycal --input data.ms --calibration calibration.jld", 
            "title": "Gain Calibration"
        }, 
        {
            "location": "/gaincal/#gain-calibration", 
            "text": "With this calibration TTCal will solve for one complex gain (amplitude and phase)\nper antenna polarization per frequency channel. That is for complex $g_i$ and\n$i$, $j$ labeling the pair of antennas composing the baseline, TTCal seeks to minimize   \n    \\sum_{i,j} \\left\\| V_{i,j} - g_i g_j^* M_{i,j} \\right\\|^2   where $V_{i,j}$ is the measured visibility and $M_{i,j}$ is the model visibility\nmeasured on the baseline $i$, $j$.  TTCal uses the iterative routine independently described by Mitchell et al. 2008  and Salvini   Wijnholds 2014 \nto solve for the complex gains.  For more information on defining a sky model see  Sky Models .  TTCal will flag frequency channels that do not converge within the specified maximum\nnumber of iterations. However, TTCal will not attempt to identify bad antennas\nthat may be poisoning the calibration. These antennas must be flagged ahead of\ntime.  TTCal assumes that the measurement set contains all baselines, multiple\nfrequency channels, but only a single integration.  Running from a Julia script  using TTCal\nms      = MeasurementSet( data.ms )\nsources = readsources( sources.json )\nbeam    = TTCal.SineBeam()\ncal = gaincal(ms, sources, beam, maxiter = 20, tolerance = 1e-3)\napplycal!(ms, cal, force_imaging_columns = true)\nunlock(ms)  Running from the command line  For a list of all available options, run:  ttcal.jl gaincal --help  To calibrate a standard OVRO LWA dataset:  ttcal.jl gaincal --input data.ms --output calibration.jld --sources sources.json\nttcal.jl applycal --input data.ms --calibration calibration.jld", 
            "title": "Gain Calibration"
        }, 
        {
            "location": "/polcal/", 
            "text": "", 
            "title": "Polarization Calibration"
        }, 
        {
            "location": "/ampcal/", 
            "text": "", 
            "title": "Amplitude Calibration"
        }, 
        {
            "location": "/sources/", 
            "text": "Sky Models\n\n\nPoint Sources\n\n\nFor the OVRO LWA, the two most important point sources for calibration are\n\nCas A\n and\n\nCyg A\n, which are the two brightest\nsources on the sky. The optimal time to solve for a calibration is when both\nof these sources are above the horizon.\n\n\nCurrently TTCal expects the sky model to be specified as a list of point sources.\nThis is accomplished by listing the sources in a \nJSON\n file.\nFor example, the following file defines a sky model consisting of Cas A and Cyg A\nusing the published spectra for \nBaars et al. 1977\n.\n\n\n[\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCas A\n,\n        \nra\n: \n23h23m24s\n,\n        \ndec\n: \n58d48m54s\n,\n        \nI\n: 555904.26,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [-0.770]\n    },\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCyg A\n,\n        \nra\n: \n19h59m28.35663s\n,\n        \ndec\n: \n+40d44m02.0970s\n,\n        \nI\n: 49545.02,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [+0.085,-0.178]\n    }\n]\n\n\n\n\nFields:\n\n\n\n\nref\n is not used by TTCal, but is intended to be a record of the origin\n  of the information used to define the source.\n\n\nname\n is the name of the source.\n\n\nra\n and \ndec\n define the J2000 location of the source.\n\n\nI\n, \nQ\n, \nU\n, and \nV\n define the Stokes parameters (in Jy) at the frequency \nfreq\n (in Hz).\n\n\nindex\n defines the spectral index of the source.\n\n\n\n\nHigher order terms are defined such that\n\n\n    \\log S = \\log S_0 + \\sum_{n=1}^N \\alpha_n \\log\\left(\\frac{\\nu}{\\nu_0}\\right)^n\n\n\nwhere $S$ is the value of a given Stokes parameter and $\\alpha_n$ represents\nthe values contained in \nindex\n.\n\n\nDiffuse Emission\n\n\nDiffuse emission is currently not supported within TTCal. Eventual support is on the\nhorizon.", 
            "title": "Sky Models"
        }, 
        {
            "location": "/sources/#sky-models", 
            "text": "Point Sources  For the OVRO LWA, the two most important point sources for calibration are Cas A  and Cyg A , which are the two brightest\nsources on the sky. The optimal time to solve for a calibration is when both\nof these sources are above the horizon.  Currently TTCal expects the sky model to be specified as a list of point sources.\nThis is accomplished by listing the sources in a  JSON  file.\nFor example, the following file defines a sky model consisting of Cas A and Cyg A\nusing the published spectra for  Baars et al. 1977 .  [\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cas A ,\n         ra :  23h23m24s ,\n         dec :  58d48m54s ,\n         I : 555904.26,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [-0.770]\n    },\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cyg A ,\n         ra :  19h59m28.35663s ,\n         dec :  +40d44m02.0970s ,\n         I : 49545.02,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [+0.085,-0.178]\n    }\n]  Fields:   ref  is not used by TTCal, but is intended to be a record of the origin\n  of the information used to define the source.  name  is the name of the source.  ra  and  dec  define the J2000 location of the source.  I ,  Q ,  U , and  V  define the Stokes parameters (in Jy) at the frequency  freq  (in Hz).  index  defines the spectral index of the source.   Higher order terms are defined such that \n    \\log S = \\log S_0 + \\sum_{n=1}^N \\alpha_n \\log\\left(\\frac{\\nu}{\\nu_0}\\right)^n \nwhere $S$ is the value of a given Stokes parameter and $\\alpha_n$ represents\nthe values contained in  index .  Diffuse Emission  Diffuse emission is currently not supported within TTCal. Eventual support is on the\nhorizon.", 
            "title": "Sky Models"
        }, 
        {
            "location": "/external/", 
            "text": "API\n\n\nAmplitudeCalibration\n\n\nGainCalibration\n\n\nMeasurementSet\n\n\nimmutable MeasurementSet\n\n\n\n\nThis type is a wrapper around \nCasaCore.Tables.Table\n that is intended to simplify most of the common interactions between TTCal and measurement sets.\n\n\nMeasurementSet(name)\n\n\n\n\nOpen the measurement set at the given location. Assorted quantities that are commonly used by TTCal are automatically loaded and stored in fields.\n\n\nPointSource\n\n\ntype PointSource\n\n\n\n\nThese sources have a multi-component power-law spectrum such that:\n\n\nlog(flux) = log(I) + index[1]*log(\u03bd/reffreq)\n                   + index[2]*log\u00b2(\u03bd/reffreq) + ...\n\n\n\n\nPolarized fluxes are obtained in a similar manner by substituting Q/U/V for I in the above expression.\n\n\nPolarizationCalibration\n\n\nimmutable PolarizationCalibration \n: Calibration\n\n\n\n\nThis type stores the information for calibrating the polarization of the interferometer. That is, it stores Jones matrices and flags for each antenna and each frequency channel.\n\n\nPolarizationCalibration(Nant, Nfreq)\n\n\n\n\nCreate a calibration table for \nNant\n antennas with \nNfreq\n frequency channels where all the Jones matrices are initially set to the identity matrix.\n\n\nampcal\n\n\nampcal(ms::MeasurementSet, sources::Vector{PointSource}, beam::BeamModel;\n       maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n       force_imaging_columns = false)\n\n\n\n\nArguments:\n\n\n\n\nms\n - the measurement set from which to derive the calibration\n\n\nsources\n - the list of points sources to use as the sky model\n\n\nbeam\n - the beam model\n\n\n\n\nKeyword Arguments:\n\n\n\n\nmaxiter\n - the maximum number of Runge-Kutta steps to take on each     frequency channel\n\n\ntolerance\n - the relative tolerance to use while checking to see if     more iterations are required\n\n\nminuvw\n - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure\n\n\nforce_imaging_columns\n - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist\n\n\n\n\napplycal!\n\n\napplycal!(ms::MeasurementSet, calibration::Calibration;\n          apply_to_corrected = false, force_imaging_columns = false)\n\n\n\n\nApply the calibration to the given measurement set.\n\n\nArguments:\n\n\n\n\nms\n - the measurement set to which the calibration will be applied\n\n\ncalibration\n - the calibration that will be applied\n\n\n\n\nKeyword Arguments:\n\n\n\n\napply_to_corrected\n - if this is set to true, the calibration will be     applied to the CORRECTED_DATA column instead of the DATA column\n\n\nforce_imaging_columns\n - if this is set to true, the calibrated data     will be written to the CORRECTED_DATA column regardless of whether     or not the column already exists\n\n\n\n\ncorrupt!\n\n\ncorrupt!(data::Array{Complex64,3}, flags::Array{Bool,3},\n         cal::PolarizationCalibration, ant1, ant2)\n\n\n\n\nCorrupt the data as if it was observed with the given calibration.\n\n\ncorrupt!(data::Array{Complex64,3}, cal::Calibration, ant1, ant2)\n\n\n\n\nCorrupt the model data as if it had been observed with an instrument with the given calibration.\n\n\ncorrupt!(data::Array{Complex64,3}, flags::Array{Bool,3},\n         cal::ScalarCalibration, ant1, ant2)\n\n\n\n\nCorrupt the data as if it was observed with the given calibration.\n\n\nfitvis\n\n\nfitvis(ms::MeasurementSet, sources::Vector{PointSource};\n       maxiter::Int = 20, tolerance::Float64 = 1e-3,\n       minuvw::Float64 = 0.0) -\n l,m\n\n\n\n\nFit for the location of each point source.\n\n\ngaincal\n\n\ngaincal(ms::MeasurementSet, sources::Vector{PointSource}, beam::BeamModel;\n        maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n        reference_antenna = \n1x\n, force_imaging_columns = false)\n\n\n\n\nSolve for the interferometer's electronic gains.\n\n\nArguments:\n\n\n\n\nms\n - the measurement set from which to derive the calibration\n\n\nsources\n - the list of points sources to use as the sky model\n\n\nbeam\n - the beam model\n\n\n\n\nKeyword Arguments:\n\n\n\n\nmaxiter\n - the maximum number of Runge-Kutta steps to take on each     frequency channel\n\n\ntolerance\n - the relative tolerance to use while checking to see if     more iterations are required\n\n\nminuvw\n - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure\n\n\nreference_antenna\n - a string containing the antenna number and polarization     whose phase will be chosen to be zero (eg. \"14y\" or \"62x\")\n\n\nforce_imaging_columns\n - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist\n\n\n\n\ngenvis\n\n\ngenvis(ms::MeasurementSet,\n       sources::Union{PointSource,Vector{PointSource}},\n       beam::BeamModel)\n\n\n\n\nGenerate model visibilities for the given list of sources and the given beam model.\n\n\nNo gridding is performed, so the runtime of this naive algorithm scales as $O(N_{base} \\times N_{source})$.\n\n\ngetspec\n\n\ngetspec(ms::MeasurementSet, dir::Direction;\n        minuvw::Float64 = 0.0) -\n xx,xy,yx,yy\n\n\n\n\nThis function extracts the spectrum in a given direction by means of an inverse discrete Fourier transform.\n\n\nNote that no gridding is performed, so this does \nnot\n use a fast Fourier transform. However, the inverse discrete Fourier transform \nis\n the least squares estimator for the flux in a given direction (if all baselines are weighted equally).\n\n\ngetspec(data, flags, l, m, u, v, w, \u03bd, ant1, ant2) -\n xx,xy,yx,yy\n\n\n\n\nCompute the spectrum of a source located at $(l,m)$ in all of the polarized correlation products.\n\n\npeel!\n\n\npeel!{T\n:Calibration}(::Type{T},\n                      ms::MeasurementSet,\n                      sources::Vector{PointSource},\n                      beam::BeamModel;\n                      maxiter = 20,\n                      tolerance = 1e-3,\n                      minuvw = 0.0)\n\n\n\n\nPeel the given list of sources from the measurement set.\n\n\nThe type supplied as the first argument determines the manner in which the sources are peeled:\n\n\n\n\nPolarizationCalibration\n - each source receives a full set of Jones matrices\n\n\nGainCalibration\n - each source receives a full set of complex gains\n\n\nAmplitudeCalibration\n - each source receives a full set of gain amplitudes\n\n\n\n\npolcal\n\n\npolcal(ms::MeasurementSet, sources::Vector{PointSources}, beam::BeamModel;\n       maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n       force_imaging_columns = false)\n\n\n\n\nSolve for the polarization properties of the interferometer.\n\n\nArguments:\n\n\n\n\nms\n - the measurement set from which to derive the calibration\n\n\nsources\n - the list of points sources to use as the sky model\n\n\nbeam\n - the beam model\n\n\n\n\nKeyword Arguments:\n\n\n\n\nmaxiter\n - the maximum number of Runge-Kutta steps to take on each     frequency channel\n\n\ntolerance\n - the relative tolerance to use while checking to see if     more iterations are required\n\n\nminuvw\n - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure\n\n\nforce_imaging_columns\n - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist\n\n\n\n\nreadsources\n\n\nreadsources(filename) -\n Vector{PointSource}\n\n\n\n\nRead the list of point sources from the given JSON file. The format must be as follows:\n\n\n[\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCas A\n,\n        \nra\n: \n23h23m24s\n,\n        \ndec\n: \n58d48m54s\n,\n        \nI\n: 555904.26,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [-0.770]\n    },\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCyg A\n,\n        \nra\n: \n19h59m28.35663s\n,\n        \ndec\n: \n+40d44m02.0970s\n,\n        \nI\n: 49545.02,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [+0.085,-0.178]\n    }\n]\n\n\n\n\nsubsrc!\n\n\nsubsrc!(ms::MeasurementSet, dir::Direction)\n\n\n\n\nSubtract all of the measured flux from a given direction.\n\n\nThis can be used to remove RFI sources provided they have a known direction.\n\n\nsubsrc!(ms::MeasurementSet,\n        sources::Vector{PointSource},\n        beam::BeamModel)\n\n\n\n\nRemove the list of sources from the measurement set.\n\n\nwritesources\n\n\nwritesources(filename, sources::Vector{PointSource})\n\n\n\n\nWrite the list of sources to the given location as a JSON file. These sources can be read back in again using the \nreadsources\n function.", 
            "title": "API"
        }, 
        {
            "location": "/external/#api", 
            "text": "AmplitudeCalibration  GainCalibration  MeasurementSet  immutable MeasurementSet  This type is a wrapper around  CasaCore.Tables.Table  that is intended to simplify most of the common interactions between TTCal and measurement sets.  MeasurementSet(name)  Open the measurement set at the given location. Assorted quantities that are commonly used by TTCal are automatically loaded and stored in fields.  PointSource  type PointSource  These sources have a multi-component power-law spectrum such that:  log(flux) = log(I) + index[1]*log(\u03bd/reffreq)\n                   + index[2]*log\u00b2(\u03bd/reffreq) + ...  Polarized fluxes are obtained in a similar manner by substituting Q/U/V for I in the above expression.  PolarizationCalibration  immutable PolarizationCalibration  : Calibration  This type stores the information for calibrating the polarization of the interferometer. That is, it stores Jones matrices and flags for each antenna and each frequency channel.  PolarizationCalibration(Nant, Nfreq)  Create a calibration table for  Nant  antennas with  Nfreq  frequency channels where all the Jones matrices are initially set to the identity matrix.  ampcal  ampcal(ms::MeasurementSet, sources::Vector{PointSource}, beam::BeamModel;\n       maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n       force_imaging_columns = false)  Arguments:   ms  - the measurement set from which to derive the calibration  sources  - the list of points sources to use as the sky model  beam  - the beam model   Keyword Arguments:   maxiter  - the maximum number of Runge-Kutta steps to take on each     frequency channel  tolerance  - the relative tolerance to use while checking to see if     more iterations are required  minuvw  - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure  force_imaging_columns  - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist   applycal!  applycal!(ms::MeasurementSet, calibration::Calibration;\n          apply_to_corrected = false, force_imaging_columns = false)  Apply the calibration to the given measurement set.  Arguments:   ms  - the measurement set to which the calibration will be applied  calibration  - the calibration that will be applied   Keyword Arguments:   apply_to_corrected  - if this is set to true, the calibration will be     applied to the CORRECTED_DATA column instead of the DATA column  force_imaging_columns  - if this is set to true, the calibrated data     will be written to the CORRECTED_DATA column regardless of whether     or not the column already exists   corrupt!  corrupt!(data::Array{Complex64,3}, flags::Array{Bool,3},\n         cal::PolarizationCalibration, ant1, ant2)  Corrupt the data as if it was observed with the given calibration.  corrupt!(data::Array{Complex64,3}, cal::Calibration, ant1, ant2)  Corrupt the model data as if it had been observed with an instrument with the given calibration.  corrupt!(data::Array{Complex64,3}, flags::Array{Bool,3},\n         cal::ScalarCalibration, ant1, ant2)  Corrupt the data as if it was observed with the given calibration.  fitvis  fitvis(ms::MeasurementSet, sources::Vector{PointSource};\n       maxiter::Int = 20, tolerance::Float64 = 1e-3,\n       minuvw::Float64 = 0.0) -  l,m  Fit for the location of each point source.  gaincal  gaincal(ms::MeasurementSet, sources::Vector{PointSource}, beam::BeamModel;\n        maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n        reference_antenna =  1x , force_imaging_columns = false)  Solve for the interferometer's electronic gains.  Arguments:   ms  - the measurement set from which to derive the calibration  sources  - the list of points sources to use as the sky model  beam  - the beam model   Keyword Arguments:   maxiter  - the maximum number of Runge-Kutta steps to take on each     frequency channel  tolerance  - the relative tolerance to use while checking to see if     more iterations are required  minuvw  - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure  reference_antenna  - a string containing the antenna number and polarization     whose phase will be chosen to be zero (eg. \"14y\" or \"62x\")  force_imaging_columns  - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist   genvis  genvis(ms::MeasurementSet,\n       sources::Union{PointSource,Vector{PointSource}},\n       beam::BeamModel)  Generate model visibilities for the given list of sources and the given beam model.  No gridding is performed, so the runtime of this naive algorithm scales as $O(N_{base} \\times N_{source})$.  getspec  getspec(ms::MeasurementSet, dir::Direction;\n        minuvw::Float64 = 0.0) -  xx,xy,yx,yy  This function extracts the spectrum in a given direction by means of an inverse discrete Fourier transform.  Note that no gridding is performed, so this does  not  use a fast Fourier transform. However, the inverse discrete Fourier transform  is  the least squares estimator for the flux in a given direction (if all baselines are weighted equally).  getspec(data, flags, l, m, u, v, w, \u03bd, ant1, ant2) -  xx,xy,yx,yy  Compute the spectrum of a source located at $(l,m)$ in all of the polarized correlation products.  peel!  peel!{T :Calibration}(::Type{T},\n                      ms::MeasurementSet,\n                      sources::Vector{PointSource},\n                      beam::BeamModel;\n                      maxiter = 20,\n                      tolerance = 1e-3,\n                      minuvw = 0.0)  Peel the given list of sources from the measurement set.  The type supplied as the first argument determines the manner in which the sources are peeled:   PolarizationCalibration  - each source receives a full set of Jones matrices  GainCalibration  - each source receives a full set of complex gains  AmplitudeCalibration  - each source receives a full set of gain amplitudes   polcal  polcal(ms::MeasurementSet, sources::Vector{PointSources}, beam::BeamModel;\n       maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n       force_imaging_columns = false)  Solve for the polarization properties of the interferometer.  Arguments:   ms  - the measurement set from which to derive the calibration  sources  - the list of points sources to use as the sky model  beam  - the beam model   Keyword Arguments:   maxiter  - the maximum number of Runge-Kutta steps to take on each     frequency channel  tolerance  - the relative tolerance to use while checking to see if     more iterations are required  minuvw  - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure  force_imaging_columns  - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist   readsources  readsources(filename) -  Vector{PointSource}  Read the list of point sources from the given JSON file. The format must be as follows:  [\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cas A ,\n         ra :  23h23m24s ,\n         dec :  58d48m54s ,\n         I : 555904.26,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [-0.770]\n    },\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cyg A ,\n         ra :  19h59m28.35663s ,\n         dec :  +40d44m02.0970s ,\n         I : 49545.02,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [+0.085,-0.178]\n    }\n]  subsrc!  subsrc!(ms::MeasurementSet, dir::Direction)  Subtract all of the measured flux from a given direction.  This can be used to remove RFI sources provided they have a known direction.  subsrc!(ms::MeasurementSet,\n        sources::Vector{PointSource},\n        beam::BeamModel)  Remove the list of sources from the measurement set.  writesources  writesources(filename, sources::Vector{PointSource})  Write the list of sources to the given location as a JSON file. These sources can be read back in again using the  readsources  function.", 
            "title": "API"
        }, 
        {
            "location": "/internal/", 
            "text": "Internal Documentation\n\n\nConstantBeam\n\n\nConstantBeam \n: BeamModel\n\n\n\n\nIn this beam model, the Jones matrix is assumed to be unity in every direction.\n\n\nJonesMatrix\n\n\nThis type represents a 2x2 complex Jones matrix.\n\n\n\u2308xx xy\u2309\n\u230ayx yy\u230b\n\n\n\n\nMemo178Beam\n\n\nMemo178Beam \n: BeamModel\n\n\n\n\nThis beam is based on the parametric fit to EM simulations presented in LWA memo 178 by Jayce Dowell.\n\n\n[http://www.faculty.ece.vt.edu/swe/lwa/memo/lwa0178a.pdf]\n\n\nRK{N}\n\n\nThis singleton type is used to indicate which Runge-Kutta method should be used. For example, \nRK{4}\n tells us to use the RK4 method.\n\n\nSineBeam\n\n\nSineBeam \n: BeamModel\n\n\n\n\nThis beam is azimuthally symmetric and independent of frequency. The gain of an individual dipole scales as $\\sin(elevation)^\\alpha$.\n\n\nampcal_step\n\n\nampcal_step(amplitudes,data,model) -\n step\n\n\n\n\nGiven the \ndata\n and \nmodel\n visibilities, and the current guess for the gain \namplitudes\n, solve for \nstep\n such that the new value of the amplitudes is \namplitudes+step\n.\n\n\ndir2azel\n\n\ndir2azel(frame::ReferenceFrame, dir::Direction)\n\n\n\n\nConvert the direction into a local azimuth and elevation.\n\n\ndir2lm\n\n\ndir2lm(phase_dir::Direction{dir\nJ2000\n}, dir::Direction{dir\nJ2000\n})\n\n\n\n\nConvert the direction into the standard radio coordinate system.\n\n\ndir2radec\n\n\ndir2radec(frame::ReferenceFrame, dir::Direction)\n\n\n\n\nConvert the direction into a J2000 right ascension and declination.\n\n\nfixphase!\n\n\nfixphase!(cal::AmplitudeCalibration, reference_antenna)\n\n\n\n\nWith an amplitude calibration there is no freedom to pick an arbitrary phase, so this function does nothing.\n\n\nfixphase!(cal::GainCalibration, reference_antenna)\n\n\n\n\nSet the phase of the reference antenna and polarization to zero.\n\n\nArguments:\n\n\n\n\ncal\n - the calibration that will have its phase adjusted\n\n\nreference_antenna\n - a string containing the antenna number and polarization     whose phase will be chosen to be zero (eg. \"14y\" or \"62x\")\n\n\n\n\nflag_short_baselines!\n\n\nflag_short_baselines!(flags, minuvw, u, v, w, \u03bd)\n\n\n\n\nFlag all of the baselines whose length is less than \nminuvw\n wavelengths.\n\n\nThis is a common operation that can mitigate contamination by unmodeled diffuse emission.\n\n\nforce_to_horizon\n\n\nforce_to_horizon(l,m)\n\n\n\n\nThis function forces the coordinates $(l,m)$ to be above the horizon.\n\n\nAlthough this is a nasty hack, it is necessary for fitting some sources that are near the horizon.\n\n\nfringepattern!\n\n\nCompute exp(i(\u03d5+n\u0394\u03d5)) where \u03d5 and \u0394\u03d5 define an equally space grid of points where n = 1 to N.\n\n\nUsing the sine and cosine angle addition rules, you can define an iterative method such that you only need to compute sines and cosines for a single iteration.\n\n\ngaincal_step\n\n\ngaincal_step(gains,data,model) -\n step\n\n\n\n\nGiven the \ndata\n and \nmodel\n visibilities, and the current guess for the electronic \ngains\n, solve for \nstep\n such that the new value of the gains is \ngains+step\n.\n\n\nThe update step is defined such that the new value of the gains minimizes\n\n\n[     \\sum_{i,j}\\|V_{i,j} - g_i g_{j,new}^* M_{i,j}\\|^2$, ]\n\n\nwhere $i$ and $j$ label the antennas, $V$ labels the measured visibilities, $M$ labels the model visibilities, and $g$ labels the complex gains.\n\n\nReferences:\n\n\n\n\nMichell, D. et al. 2008, JSTSP, 2, 5.\n\n\nSalvini, S. \n Wijnholds, S. 2014, A\nA, 571, 97.\n\n\n\n\nget_corrected_data\n\n\nget_corrected_data(ms::MeasurementSet)\n\n\n\n\nGet the CORRECTED_DATA column if it exists. Otherwise settle for the DATA column.\n\n\nget_flags\n\n\nget_flags(ms::MeasurementSet)\n\n\n\n\nGet the flags from the dataset, but this information is stored in multiple locations. Unify all these flags before returning.\n\n\ninvert\n\n\ninvert(cal::ScalarCalibration)\n\n\n\n\nReturns the inverse of the given calibration. The gain $g$ of each antenna is set to $1/g$.\n\n\ninvert(cal::PolarizationCalibration)\n\n\n\n\nReturns the inverse of the given calibration. The Jones matrix $J$ of each antenna is set to $J^{-1}$.\n\n\nlatlong_to_utm\n\n\nlatlong_to_utm(zone, latitude, longitude)\n\n\n\n\nConvert the latitude and longitude (both in degrees) to an easting and a northing (both in meters).\n\n\nThis function is entirely based on the \nUniversal Transverse Mercator coordinate system\n Wikipedia page.\n\n\nlinear\n\n\nlinear(stokes) -\n [xx,xy,yx,yy]\n\n\n\n\nTake the vector of Stokes parameters \n[I,Q,U,V]\n and convert it to the vector of linear correlations.\n\n\nmueller\n\n\nmueller(J::JonesMatrix)\n\n\n\n\nCreate a Mueller matrix from the given Jones matrix.\n\n\nmueller(J1::JonesMatrix, J2::JonesMatrix)\n\n\n\n\nCreate a Mueller matrix from the two Jones matrices.\n\n\npolcal_makesquare\n\n\npolcal_makesquare(data, flags, ant1, ant2)\n\n\n\n\nPack the data into a square Hermitian matrix where each element is a Jones matrix.\n\n\nCompare this to the regular complex gain calibration where each element is a complex scalar.\n\n\nThe packing order is:\n\n\n11 12 13\n21 22 23\n31 32 33\n         .\n           .\n             .\n\n\n\n\npolcal_step\n\n\npolcal_step(jones,data,model) -\n step\n\n\n\n\nGiven the \ndata\n and \nmodel\n visibilities, and the current guess for the Jones matrices (\njones\n), solve for \nstep\n such that the new value of the Jones matrices is \njones+step\n.\n\n\nrkstep\n\n\nTake a Runge-Kutta step. * \nstep(x,args...)\n must return the list of steps to take from the given location \nx\n * \nrk\n is the order of the Runge-Kutta method to use (eg. \nRK4\n) * \nx\n is the starting location * \nargs\n is simply passed on as the second argument to \nstep\n\n\nscalar_makesquare\n\n\nscalar_makesquare(data, flags, ant1, ant2)\n\n\n\n\nPack the data into a square Hermitian matrix such that the data is ordered as follows:\n\n\nx\u2081x\u2081 x\u2081y\u2081 x\u2081x\u2082 x\u2081y\u2082\ny\u2081x\u2081 y\u2081y\u2081 y\u2081x\u2082 y\u2081y\u2082\nx\u2082x\u2081 y\u2082y\u2081 y\u2082x\u2082 y\u2082y\u2082\ny\u2082x\u2081 y\u2082y\u2081 y\u2082x\u2082 y\u2082y\u2082\n                     .\n                       .\n                         .\n\n\n\n\nFlagged correlations and autocorrelations are set to zero.\n\n\nstokes\n\n\nstokes(correlations) -\n [I,Q,U,V]\n\n\n\n\nTake the vector of correlations \n[xx,xy,yx,yy]\n and convert it to the Stokes parameters.\n\n\nutm_to_latlong\n\n\nutm_to_latlong(zone, easting, northing,\n               hemisphere = north)\n\n\n\n\nConvert the easting and northing (both in meters) to a latitude and longitude (both in degrees).\n\n\nThis function is entirely based on the \nUniversal Transverse Mercator coordinate system\n Wikipedia page.\n\n\nwrite_ds9_regions\n\n\nwrite_ds9_regions(filename, sources::Vector{PointSource})\n\n\n\n\nWrite the list of sources to a DS9 region file. This file can then be loaded into DS9 to highlight sources within images.", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/internal/#internal-documentation", 
            "text": "ConstantBeam  ConstantBeam  : BeamModel  In this beam model, the Jones matrix is assumed to be unity in every direction.  JonesMatrix  This type represents a 2x2 complex Jones matrix.  \u2308xx xy\u2309\n\u230ayx yy\u230b  Memo178Beam  Memo178Beam  : BeamModel  This beam is based on the parametric fit to EM simulations presented in LWA memo 178 by Jayce Dowell.  [http://www.faculty.ece.vt.edu/swe/lwa/memo/lwa0178a.pdf]  RK{N}  This singleton type is used to indicate which Runge-Kutta method should be used. For example,  RK{4}  tells us to use the RK4 method.  SineBeam  SineBeam  : BeamModel  This beam is azimuthally symmetric and independent of frequency. The gain of an individual dipole scales as $\\sin(elevation)^\\alpha$.  ampcal_step  ampcal_step(amplitudes,data,model) -  step  Given the  data  and  model  visibilities, and the current guess for the gain  amplitudes , solve for  step  such that the new value of the amplitudes is  amplitudes+step .  dir2azel  dir2azel(frame::ReferenceFrame, dir::Direction)  Convert the direction into a local azimuth and elevation.  dir2lm  dir2lm(phase_dir::Direction{dir J2000 }, dir::Direction{dir J2000 })  Convert the direction into the standard radio coordinate system.  dir2radec  dir2radec(frame::ReferenceFrame, dir::Direction)  Convert the direction into a J2000 right ascension and declination.  fixphase!  fixphase!(cal::AmplitudeCalibration, reference_antenna)  With an amplitude calibration there is no freedom to pick an arbitrary phase, so this function does nothing.  fixphase!(cal::GainCalibration, reference_antenna)  Set the phase of the reference antenna and polarization to zero.  Arguments:   cal  - the calibration that will have its phase adjusted  reference_antenna  - a string containing the antenna number and polarization     whose phase will be chosen to be zero (eg. \"14y\" or \"62x\")   flag_short_baselines!  flag_short_baselines!(flags, minuvw, u, v, w, \u03bd)  Flag all of the baselines whose length is less than  minuvw  wavelengths.  This is a common operation that can mitigate contamination by unmodeled diffuse emission.  force_to_horizon  force_to_horizon(l,m)  This function forces the coordinates $(l,m)$ to be above the horizon.  Although this is a nasty hack, it is necessary for fitting some sources that are near the horizon.  fringepattern!  Compute exp(i(\u03d5+n\u0394\u03d5)) where \u03d5 and \u0394\u03d5 define an equally space grid of points where n = 1 to N.  Using the sine and cosine angle addition rules, you can define an iterative method such that you only need to compute sines and cosines for a single iteration.  gaincal_step  gaincal_step(gains,data,model) -  step  Given the  data  and  model  visibilities, and the current guess for the electronic  gains , solve for  step  such that the new value of the gains is  gains+step .  The update step is defined such that the new value of the gains minimizes  [     \\sum_{i,j}\\|V_{i,j} - g_i g_{j,new}^* M_{i,j}\\|^2$, ]  where $i$ and $j$ label the antennas, $V$ labels the measured visibilities, $M$ labels the model visibilities, and $g$ labels the complex gains.  References:   Michell, D. et al. 2008, JSTSP, 2, 5.  Salvini, S.   Wijnholds, S. 2014, A A, 571, 97.   get_corrected_data  get_corrected_data(ms::MeasurementSet)  Get the CORRECTED_DATA column if it exists. Otherwise settle for the DATA column.  get_flags  get_flags(ms::MeasurementSet)  Get the flags from the dataset, but this information is stored in multiple locations. Unify all these flags before returning.  invert  invert(cal::ScalarCalibration)  Returns the inverse of the given calibration. The gain $g$ of each antenna is set to $1/g$.  invert(cal::PolarizationCalibration)  Returns the inverse of the given calibration. The Jones matrix $J$ of each antenna is set to $J^{-1}$.  latlong_to_utm  latlong_to_utm(zone, latitude, longitude)  Convert the latitude and longitude (both in degrees) to an easting and a northing (both in meters).  This function is entirely based on the  Universal Transverse Mercator coordinate system  Wikipedia page.  linear  linear(stokes) -  [xx,xy,yx,yy]  Take the vector of Stokes parameters  [I,Q,U,V]  and convert it to the vector of linear correlations.  mueller  mueller(J::JonesMatrix)  Create a Mueller matrix from the given Jones matrix.  mueller(J1::JonesMatrix, J2::JonesMatrix)  Create a Mueller matrix from the two Jones matrices.  polcal_makesquare  polcal_makesquare(data, flags, ant1, ant2)  Pack the data into a square Hermitian matrix where each element is a Jones matrix.  Compare this to the regular complex gain calibration where each element is a complex scalar.  The packing order is:  11 12 13\n21 22 23\n31 32 33\n         .\n           .\n             .  polcal_step  polcal_step(jones,data,model) -  step  Given the  data  and  model  visibilities, and the current guess for the Jones matrices ( jones ), solve for  step  such that the new value of the Jones matrices is  jones+step .  rkstep  Take a Runge-Kutta step. *  step(x,args...)  must return the list of steps to take from the given location  x  *  rk  is the order of the Runge-Kutta method to use (eg.  RK4 ) *  x  is the starting location *  args  is simply passed on as the second argument to  step  scalar_makesquare  scalar_makesquare(data, flags, ant1, ant2)  Pack the data into a square Hermitian matrix such that the data is ordered as follows:  x\u2081x\u2081 x\u2081y\u2081 x\u2081x\u2082 x\u2081y\u2082\ny\u2081x\u2081 y\u2081y\u2081 y\u2081x\u2082 y\u2081y\u2082\nx\u2082x\u2081 y\u2082y\u2081 y\u2082x\u2082 y\u2082y\u2082\ny\u2082x\u2081 y\u2082y\u2081 y\u2082x\u2082 y\u2082y\u2082\n                     .\n                       .\n                         .  Flagged correlations and autocorrelations are set to zero.  stokes  stokes(correlations) -  [I,Q,U,V]  Take the vector of correlations  [xx,xy,yx,yy]  and convert it to the Stokes parameters.  utm_to_latlong  utm_to_latlong(zone, easting, northing,\n               hemisphere = north)  Convert the easting and northing (both in meters) to a latitude and longitude (both in degrees).  This function is entirely based on the  Universal Transverse Mercator coordinate system  Wikipedia page.  write_ds9_regions  write_ds9_regions(filename, sources::Vector{PointSource})  Write the list of sources to a DS9 region file. This file can then be loaded into DS9 to highlight sources within images.", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "", 
            "title": "Contributing"
        }, 
        {
            "location": "/docs/", 
            "text": "Building this Website\n\n\nThis website is built using \nMkDocs\n and hosted\non \nGithub Pages\n. Building and deploying the\ndocumentation will require a little bit of setup.\n\n\n\n\nRun \npip install --user mkdocs\n to obtain MkDocs.\n\n\nRun \npip install --user python-markdown-math\n to obtain the markdown\n   extension that allows LaTeX-style math.\n\n\nRun \ndocs/gendocs.jl\n to extract the documentation from the Julia\n   source code into the relevant Markdown files.\n\n\nRun \nmkdocs serve\n and navigate your web browser to\n   \nhttp://127.0.0.1:8000\n\n   to check that everything looks correct.\n\n\nRun \nmkdocs gh-deploy\n to deploy the new documentation to Github Pages.\n\n\nCommit all your changes.", 
            "title": "Building this Website"
        }, 
        {
            "location": "/docs/#building-this-website", 
            "text": "This website is built using  MkDocs  and hosted\non  Github Pages . Building and deploying the\ndocumentation will require a little bit of setup.   Run  pip install --user mkdocs  to obtain MkDocs.  Run  pip install --user python-markdown-math  to obtain the markdown\n   extension that allows LaTeX-style math.  Run  docs/gendocs.jl  to extract the documentation from the Julia\n   source code into the relevant Markdown files.  Run  mkdocs serve  and navigate your web browser to\n    http://127.0.0.1:8000 \n   to check that everything looks correct.  Run  mkdocs gh-deploy  to deploy the new documentation to Github Pages.  Commit all your changes.", 
            "title": "Building this Website"
        }
    ]
}