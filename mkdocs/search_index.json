{
    "docs": [
        {
            "location": "/", 
            "text": "TTCal\n\n\n\n\nTTCal is a calibration routine developed for the OVRO LWA.\n\n\nOverview\n\n\nThe standard procedure for phase calibrating a radio interferometer\nusually involves slewing a small number of large dishes to stare at\na known point source. A point source at the phase center of the\ninterferometer has zero phase on all baselines, so phase calibration\nessentially amounts to zeroing the phase on all baselines.\n\n\nLow frequency telescopes (\n300 MHz) tend to occupy an entirely different\nregion of phase space. That is they are usually composed of numerous\ncheap dipole antennas with very broad beams (\nLOFAR\n,\n\nMWA\n). Furthermore, the low frequency sky\nis corrupted by propagation through the ionosphere. Until the field matures,\nthe demand for a new and effective calibration technique\nis best met by a simple, adaptable, and relatively fast software package.\nThis is why I wrote TTCal.\n\n\nGetting Started\n\n\nTTCal requires version 0.4 of the \nJulia\n programming\nlanguage. Julia is a dynamic language designed for scientific computing with\na just-in-time compiler based on \nLLVM\n. The syntax\nshould be familiar to users of \nMatlab\n\nand \nPython\n, but Python users should be aware\nthat the first element of an array is accessed with \nx[1]\n.\n\n\nOnce Julia is installed, the REPL (read-eval-print loop) can be started by\ntyping \njulia\n from the command line. Try running the following examples:\n\n\njulia\n 1+1\n2\n\njulia\n for i = 1:3\n           println(rand())\n       end\n0.8165122957881887\n0.8315752097289137\n0.6558156424738537\n\n\n\n\nTTCal depends on the \nCasaCore.jl\n\npackage, which is a Julia wrapper of the \ncasacore\n\nlibrary. It is used to interface with measurement sets and perform\ncoordinate conversions.\n\n\nTo install TTCal, run:\n\n\n# Get the latest version of CasaCore.jl and build the wrapper\njulia\n Pkg.clone(\nCasaCore\n)\njulia\n Pkg.build(\nCasaCore\n)\n# Get the latest version of TTCal\njulia\n Pkg.clone(\nhttps://github.com/mweastwood/TTCal.jl.git\n)\njulia\n Pkg.update()\njulia\n Pkg.test(\nTTCal\n)\n\n\n\n\nIf all the tests pass, you are ready to begin using TTCal.\n\n\nWhile the most powerful interface to TTCal involves writing small\nJulia scripts, a limited command line interface is available.\nSimply add the \nttcal.jl\n file to your \nPATH\n environment variable.\nYou can see the list of available commands by running:\n\n\n$ ttcal.jl --help\nusage: ttcal.jl [-h] {gaincal|polcal|peel|applycal}\n\nA calibration routine developed for the OVRO LWA.\n\ncommands:\n  gaincal     Solve for a gain calibration.\n  polcal      Solve for a polarization calibration.\n  peel        Peel sources from the dataset.\n  applycal    Apply a calibration.\n\noptional arguments:\n  -h, --help  show this help message and exit\n\n\n\n\nNote that every time Julia is restarted there is overhead\nassociated with reloading and recompiling the code. While\nJulia version 0.4 introduced code caching to help mitigate this,\nrunning TTCal will always be faster from a Julia script\nthan from the command line.\n\n\nBugs\n\n\nIf you encounter any problems, please\n\nopen an issue\n\non Github.\n\n\nKnown problems are listed as\n\nopen issues\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#ttcal", 
            "text": "TTCal is a calibration routine developed for the OVRO LWA.", 
            "title": "TTCal"
        }, 
        {
            "location": "/#overview", 
            "text": "The standard procedure for phase calibrating a radio interferometer\nusually involves slewing a small number of large dishes to stare at\na known point source. A point source at the phase center of the\ninterferometer has zero phase on all baselines, so phase calibration\nessentially amounts to zeroing the phase on all baselines.  Low frequency telescopes ( 300 MHz) tend to occupy an entirely different\nregion of phase space. That is they are usually composed of numerous\ncheap dipole antennas with very broad beams ( LOFAR , MWA ). Furthermore, the low frequency sky\nis corrupted by propagation through the ionosphere. Until the field matures,\nthe demand for a new and effective calibration technique\nis best met by a simple, adaptable, and relatively fast software package.\nThis is why I wrote TTCal.", 
            "title": "Overview"
        }, 
        {
            "location": "/#getting-started", 
            "text": "TTCal requires version 0.4 of the  Julia  programming\nlanguage. Julia is a dynamic language designed for scientific computing with\na just-in-time compiler based on  LLVM . The syntax\nshould be familiar to users of  Matlab \nand  Python , but Python users should be aware\nthat the first element of an array is accessed with  x[1] .  Once Julia is installed, the REPL (read-eval-print loop) can be started by\ntyping  julia  from the command line. Try running the following examples:  julia  1+1\n2\n\njulia  for i = 1:3\n           println(rand())\n       end\n0.8165122957881887\n0.8315752097289137\n0.6558156424738537  TTCal depends on the  CasaCore.jl \npackage, which is a Julia wrapper of the  casacore \nlibrary. It is used to interface with measurement sets and perform\ncoordinate conversions.  To install TTCal, run:  # Get the latest version of CasaCore.jl and build the wrapper\njulia  Pkg.clone( CasaCore )\njulia  Pkg.build( CasaCore )\n# Get the latest version of TTCal\njulia  Pkg.clone( https://github.com/mweastwood/TTCal.jl.git )\njulia  Pkg.update()\njulia  Pkg.test( TTCal )  If all the tests pass, you are ready to begin using TTCal.  While the most powerful interface to TTCal involves writing small\nJulia scripts, a limited command line interface is available.\nSimply add the  ttcal.jl  file to your  PATH  environment variable.\nYou can see the list of available commands by running:  $ ttcal.jl --help\nusage: ttcal.jl [-h] {gaincal|polcal|peel|applycal}\n\nA calibration routine developed for the OVRO LWA.\n\ncommands:\n  gaincal     Solve for a gain calibration.\n  polcal      Solve for a polarization calibration.\n  peel        Peel sources from the dataset.\n  applycal    Apply a calibration.\n\noptional arguments:\n  -h, --help  show this help message and exit  Note that every time Julia is restarted there is overhead\nassociated with reloading and recompiling the code. While\nJulia version 0.4 introduced code caching to help mitigate this,\nrunning TTCal will always be faster from a Julia script\nthan from the command line.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#bugs", 
            "text": "If you encounter any problems, please open an issue \non Github.  Known problems are listed as open issues .", 
            "title": "Bugs"
        }, 
        {
            "location": "/gaincal/", 
            "text": "Gain Calibration\n\n\nWith this calibration TTCal will solve for one complex gain (amplitude and phase)\nper antenna polarization per frequency channel. That is for complex $g_i$ and\n$i$, $j$ labeling the pair of antennas composing the baseline, TTCal seeks to minimize\n\n\n\n\n\n    \\sum_{i,j} \\left\\| V_{i,j} - g_i g_j^* M_{i,j} \\right\\|^2\n\n\n\n\n\nwhere $V_{i,j}$ is the measured visibility and $M_{i,j}$ is the model visibility\nmeasured on the baseline $i$, $j$.\n\n\nTTCal uses the iterative routine independently described by\n\nMitchell et al. 2008\n and\n\nSalvini \n Wijnholds 2014\n\nto solve for the complex gains.\n\n\nFor more information on defining a sky model see \nSky Models\n.\n\n\nTTCal will flag frequency channels that do not converge within the specified maximum\nnumber of iterations. However, TTCal will not attempt to identify bad antennas\nthat may be poisoning the calibration. These antennas must be flagged ahead of\ntime.\n\n\nTTCal assumes that the measurement set contains all baselines, multiple\nfrequency channels, but only a single integration.\n\n\nRunning from a Julia script\n\n\nusing TTCal\nms      = MeasurementSet(\ndata.ms\n)\nsources = readsources(\nsources.json\n)\nbeam    = TTCal.SineBeam()\ncal = gaincal(ms, sources, beam, maxiter = 20, tolerance = 1e-3)\napplycal!(ms, cal, force_imaging_columns = true)\nunlock(ms)\n\n\n\n\nRunning from the command line\n\n\nFor a list of all available options, run:\n\n\nttcal.jl gaincal --help\n\n\n\n\nTo calibrate a standard OVRO LWA dataset:\n\n\nttcal.jl gaincal --input data.ms --output calibration.jld --sources sources.json\nttcal.jl applycal --input data.ms --calibration calibration.jld", 
            "title": "Gain Calibration"
        }, 
        {
            "location": "/gaincal/#gain-calibration", 
            "text": "With this calibration TTCal will solve for one complex gain (amplitude and phase)\nper antenna polarization per frequency channel. That is for complex $g_i$ and\n$i$, $j$ labeling the pair of antennas composing the baseline, TTCal seeks to minimize   \n    \\sum_{i,j} \\left\\| V_{i,j} - g_i g_j^* M_{i,j} \\right\\|^2   where $V_{i,j}$ is the measured visibility and $M_{i,j}$ is the model visibility\nmeasured on the baseline $i$, $j$.  TTCal uses the iterative routine independently described by Mitchell et al. 2008  and Salvini   Wijnholds 2014 \nto solve for the complex gains.  For more information on defining a sky model see  Sky Models .  TTCal will flag frequency channels that do not converge within the specified maximum\nnumber of iterations. However, TTCal will not attempt to identify bad antennas\nthat may be poisoning the calibration. These antennas must be flagged ahead of\ntime.  TTCal assumes that the measurement set contains all baselines, multiple\nfrequency channels, but only a single integration.  Running from a Julia script  using TTCal\nms      = MeasurementSet( data.ms )\nsources = readsources( sources.json )\nbeam    = TTCal.SineBeam()\ncal = gaincal(ms, sources, beam, maxiter = 20, tolerance = 1e-3)\napplycal!(ms, cal, force_imaging_columns = true)\nunlock(ms)  Running from the command line  For a list of all available options, run:  ttcal.jl gaincal --help  To calibrate a standard OVRO LWA dataset:  ttcal.jl gaincal --input data.ms --output calibration.jld --sources sources.json\nttcal.jl applycal --input data.ms --calibration calibration.jld", 
            "title": "Gain Calibration"
        }, 
        {
            "location": "/polcal/", 
            "text": "", 
            "title": "Polarization Calibration"
        }, 
        {
            "location": "/ampcal/", 
            "text": "", 
            "title": "Amplitude Calibration"
        }, 
        {
            "location": "/sources/", 
            "text": "Sky Models\n\n\nPoint Sources\n\n\nFor the OVRO LWA, the two most important point sources for calibration are\n\nCas A\n and\n\nCyg A\n, which are the two brightest\nsources on the sky. The optimal time to solve for a calibration is when both\nof these sources are above the horizon.\n\n\nCurrently TTCal expects the sky model to be specified as a list of point sources.\nThis is accomplished by listing the sources in a \nJSON\n file.\nFor example, the following file defines a sky model consisting of Cas A and Cyg A\nusing the published spectra for \nBaars et al. 1977\n.\n\n\n[\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCas A\n,\n        \nra\n: \n23h23m24s\n,\n        \ndec\n: \n58d48m54s\n,\n        \nI\n: 555904.26,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [-0.770]\n    },\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCyg A\n,\n        \nra\n: \n19h59m28.35663s\n,\n        \ndec\n: \n+40d44m02.0970s\n,\n        \nI\n: 49545.02,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [+0.085,-0.178]\n    }\n]\n\n\n\n\nFields:\n\n\n\n\nref\n is not used by TTCal, but is intended to be a record of the origin\n  of the information used to define the source.\n\n\nname\n is the name of the source.\n\n\nra\n and \ndec\n define the J2000 location of the source.\n\n\nI\n, \nQ\n, \nU\n, and \nV\n define the Stokes parameters (in Jy) at the frequency \nfreq\n (in Hz).\n\n\nindex\n defines the spectral index of the source.\n\n\n\n\nHigher order terms are defined such that\n\n\n    \\log_{10} S = \\log_{10} S_0 + \\sum_{n=1}^N \\alpha_n \\log_{10}\\left(\\frac{\\nu}{\\nu_0}\\right)^n\n\n\nwhere $S$ is the value of a given Stokes parameter and $\\alpha_n$ represents\nthe values contained in \nindex\n.\n\n\nDiffuse Emission\n\n\nDiffuse emission is currently not supported within TTCal. Eventual support is on the\nhorizon.", 
            "title": "Sky Models"
        }, 
        {
            "location": "/sources/#sky-models", 
            "text": "Point Sources  For the OVRO LWA, the two most important point sources for calibration are Cas A  and Cyg A , which are the two brightest\nsources on the sky. The optimal time to solve for a calibration is when both\nof these sources are above the horizon.  Currently TTCal expects the sky model to be specified as a list of point sources.\nThis is accomplished by listing the sources in a  JSON  file.\nFor example, the following file defines a sky model consisting of Cas A and Cyg A\nusing the published spectra for  Baars et al. 1977 .  [\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cas A ,\n         ra :  23h23m24s ,\n         dec :  58d48m54s ,\n         I : 555904.26,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [-0.770]\n    },\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cyg A ,\n         ra :  19h59m28.35663s ,\n         dec :  +40d44m02.0970s ,\n         I : 49545.02,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [+0.085,-0.178]\n    }\n]  Fields:   ref  is not used by TTCal, but is intended to be a record of the origin\n  of the information used to define the source.  name  is the name of the source.  ra  and  dec  define the J2000 location of the source.  I ,  Q ,  U , and  V  define the Stokes parameters (in Jy) at the frequency  freq  (in Hz).  index  defines the spectral index of the source.   Higher order terms are defined such that \n    \\log_{10} S = \\log_{10} S_0 + \\sum_{n=1}^N \\alpha_n \\log_{10}\\left(\\frac{\\nu}{\\nu_0}\\right)^n \nwhere $S$ is the value of a given Stokes parameter and $\\alpha_n$ represents\nthe values contained in  index .  Diffuse Emission  Diffuse emission is currently not supported within TTCal. Eventual support is on the\nhorizon.", 
            "title": "Sky Models"
        }, 
        {
            "location": "/external/", 
            "text": "API\n\n\nConstantBeam\n\n\nConstantBeam \n: BeamModel\n\n\n\n\nIn this beam model, the Jones matrix is assumed to be unity in every direction.\n\n\nDiagonalJonesMatrix\n\n\nimmutable DiagonalJonesMatrix\n\n\n\n\nThis type represents a Jones matrix that is diagonal.\n\n\nThese matrices are used to represent the complex gains of each antenna without accounting for the off-diagonal polarization leakage terms.\n\n\nGainCalibration\n\n\nimmutable GainCalibration \n: Calibration\n\n\n\n\nThis type stores the information for calibrating the electronic gains of the interferometer. That is, it stores complex gains and flags for each antenna, frequency channel, and polarization.\n\n\nGainCalibration(Nant, Nfreq)\n\n\n\n\nCreate a calibration table for \nNant\n antennas with \nNfreq\n frequency channels where all the gains are initially set to unity.\n\n\nHermitianJonesMatrix\n\n\nimmutable HermitianJonesMatrix\n\n\n\n\nThis type represents a Jones matrix that is Hermitian.\n\n\nThese matrices are useful for representing the $xx$, $xy$, $yx$, and $yy$ flux, because $xx$ and $yy$ are constrained to be real while $xy$ and $yx$ are complex conjugates.\n\n\nJonesMatrix\n\n\nimmutable JonesMatrix\n\n\n\n\nThis type represents a 2x2 complex Jones matrix.\n\n\n\n\n \\begin{pmatrix}     j_{xx} & j_{xy} \\\\\n    j_{yx} & j_{yy} \\\\\n\\end{pmatrix} \n\n\n\n\nMeasurementSet\n\n\nimmutable MeasurementSet\n\n\n\n\nThis type is a wrapper around \nCasaCore.Tables.Table\n that is intended to simplify most of the common interactions between TTCal and measurement sets.\n\n\nMeasurementSet(name)\n\n\n\n\nOpen the measurement set at the given location. Assorted quantities that are commonly used by TTCal are automatically loaded and stored in fields.\n\n\nMemo178Beam\n\n\nMemo178Beam \n: BeamModel\n\n\n\n\nThis beam is based on the parametric fit to EM simulations presented in LWA memo 178 by Jayce Dowell.\n\n\n[http://www.faculty.ece.vt.edu/swe/lwa/memo/lwa0178a.pdf]\n\n\nMuellerMatrix\n\n\nimmutable MuellerMatrix\n\n\n\n\nThis type represents a Mueller matrix.\n\n\nMuellerMatrix(J::JonesMatrix)\n\n\n\n\nCreate a Mueller matrix from the given Jones matrix.\n\n\nPoint\n\n\nPolarizationCalibration\n\n\nimmutable PolarizationCalibration \n: Calibration\n\n\n\n\nThis type stores the information for calibrating the polarization of the interferometer. That is, it stores Jones matrices and flags for each antenna and each frequency channel.\n\n\nPolarizationCalibration(Nant, Nfreq)\n\n\n\n\nCreate a calibration table for \nNant\n antennas with \nNfreq\n frequency channels where all the Jones matrices are initially set to the identity matrix.\n\n\nSineBeam\n\n\nSineBeam \n: BeamModel\n\n\n\n\nThis beam is azimuthally symmetric and independent of frequency. The gain of an individual dipole scales as $\\sin(elevation)^\\alpha$.\n\n\nSource\n\n\nimmutable Source\n\n\n\n\nThis type represents a radio source.\n\n\nEach source is composed of one or more components.\n\n\nSpectrum\n\n\nimmutable Spectrum\n\n\n\n\nThese sources have a multi-component power-law spectrum such that:\n\n\n\n\n     \\log_{10} S = \\log_{10} S_0 + \\sum_{n=1}^N \\alpha_n \\log_{10}\\left(\\frac{\\nu}{\\nu_0}\\right)^n \n\n\n\n\nwhere $S$ is a Stokes parameter, and $\\alpha_n$ is the list of spectral indices. At least one spectral index needs to be provided.\n\n\nStokesVector\n\n\nimmutable StokesVector\n\n\n\n\nThis type represents a Stokes vector.\n\n\n\n\n \\begin{pmatrix}     I \\\\\n    Q \\\\\n    U \\\\\n    V \\\\\n\\end{pmatrix} \n\n\n\n\napplycal!\n\n\napplycal!(ms::MeasurementSet, calibration::Calibration;\n          apply_to_corrected = false, force_imaging_columns = false)\n\n\n\n\nApply the calibration to the given measurement set.\n\n\nArguments:\n\n\n\n\nms\n - the measurement set to which the calibration will be applied\n\n\ncalibration\n - the calibration that will be applied\n\n\n\n\nKeyword Arguments:\n\n\n\n\napply_to_corrected\n - if this is set to true, the calibration will be     applied to the CORRECTED_DATA column instead of the DATA column\n\n\nforce_imaging_columns\n - if this is set to true, the calibrated data     will be written to the CORRECTED_DATA column regardless of whether     or not the column already exists\n\n\n\n\ncorrupt!\n\n\ncorrupt!(data::Array{Complex64,3}, cal::Calibration, ant1, ant2)\n\n\n\n\nCorrupt the model data as if it had been observed with an instrument with the given calibration.\n\n\ncorrupt!(data::Array{Complex64,3}, flags::Array{Bool,3},\n         cal::Calibration, ant1, ant2)\n\n\n\n\nCorrupt the data as if it was observed with the given calibration.\n\n\nfitvis\n\n\nfitvis(ms::MeasurementSet, direction::Direction;\n       maxiter = 20, tolerance = 1e-3, minuvw = 0.0) -\n l,m\n\n\n\n\nFit for the location of a point source near the given direction.\n\n\ngaincal\n\n\ngaincal(ms::MeasurementSet, sources::Vector{Source}, beam::BeamModel;\n        maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n        reference_antenna = \n1x\n, force_imaging_columns = false)\n\n\n\n\nSolve for the interferometer's electronic gains.\n\n\nArguments:\n\n\n\n\nms\n - the measurement set from which to derive the calibration\n\n\nsources\n - the list of points sources to use as the sky model\n\n\nbeam\n - the beam model\n\n\n\n\nKeyword Arguments:\n\n\n\n\nmaxiter\n - the maximum number of Runge-Kutta steps to take on each     frequency channel\n\n\ntolerance\n - the relative tolerance to use while checking to see if     more iterations are required\n\n\nminuvw\n - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure\n\n\nreference_antenna\n - a string containing the antenna number and polarization     whose phase will be chosen to be zero (eg. \"14y\" or \"62x\")\n\n\nforce_imaging_columns\n - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist\n\n\n\n\ngenvis\n\n\ngenvis(ms::MeasurementSet, sources, beam::BeamModel)\n\n\n\n\nGenerate model visibilities for the given list of sources and the given beam model.\n\n\nNo gridding is performed, so the runtime of this naive algorithm scales as $O(N_{base} \\times N_{source})$.\n\n\ngetspec\n\n\ngetspec(data, flags, l, m, u, v, w, \u03bd, ant1, ant2) -\n Vector{HermitianJonesMatrix}\n\n\n\n\nCompute the spectrum of a source located at $(l,m)$ in all of the polarized correlation products.\n\n\ngetspec(ms::MeasurementSet, direction::Direction;\n        minuvw = 0.0) -\n Vector{HermitianJonesMatrix}\n\n\n\n\nThis function extracts the spectrum in a given direction by means of an inverse discrete Fourier transform.\n\n\nNote that no gridding is performed, so this does \nnot\n use a fast Fourier transform. However, the inverse discrete Fourier transform \nis\n the least squares estimator for the flux in a given direction (if all baselines are weighted equally).\n\n\npeel!\n\n\npeel!{T\n:Calibration}(::Type{T},\n                      ms::MeasurementSet,\n                      sources::Vector{Source},\n                      beam::BeamModel;\n                      peeliter = 3,\n                      maxiter = 20,\n                      tolerance = 1e-3,\n                      minuvw = 0.0)\n\n\n\n\nPeel the given list of sources from the measurement set.\n\n\nThe type supplied as the first argument determines the manner in which the sources are peeled:\n\n\n\n\nPolarizationCalibration\n - each source receives a full set of Jones matrices\n\n\nGainCalibration\n - each source receives a full set of complex gains\n\n\nAmplitudeCalibration\n - each source receives a full set of gain amplitudes\n\n\n\n\npolcal\n\n\npolcal(ms::MeasurementSet, sources::Vector{Source}, beam::BeamModel;\n       maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n       force_imaging_columns = false)\n\n\n\n\nSolve for the polarization properties of the interferometer.\n\n\nArguments:\n\n\n\n\nms\n - the measurement set from which to derive the calibration\n\n\nsources\n - the list of points sources to use as the sky model\n\n\nbeam\n - the beam model\n\n\n\n\nKeyword Arguments:\n\n\n\n\nmaxiter\n - the maximum number of Runge-Kutta steps to take on each     frequency channel\n\n\ntolerance\n - the relative tolerance to use while checking to see if     more iterations are required\n\n\nminuvw\n - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure\n\n\nforce_imaging_columns\n - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist\n\n\n\n\nreadsources\n\n\nreadsources(filename) -\n Vector{Source}\n\n\n\n\nRead the list of point sources from the given JSON file. The format must be as follows:\n\n\n[\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCas A\n,\n        \nra\n: \n23h23m24s\n,\n        \ndec\n: \n58d48m54s\n,\n        \nI\n: 555904.26,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [-0.770]\n    },\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCyg A\n,\n        \nra\n: \n19h59m28.35663s\n,\n        \ndec\n: \n+40d44m02.0970s\n,\n        \nI\n: 49545.02,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [+0.085,-0.178]\n    }\n]\n\n\n\n\nAdditional Stokes parameters may also be specified.\n\n\n{\n    ...\n    \nI\n: 100\n    \nQ\n: 20\n    \nU\n: 3.14\n    \nV\n: -30\n    ...\n}\n\n\n\n\nA right ascension and declination does not need to be specified if the name of the source is \"Sun\", \"Moon\", or \"Jupiter\". These sources will have their location automatically determined by CasaCore.\n\n\nsubsrc!\n\n\nsubsrc!(ms::MeasurementSet, dir::Direction; minuvw = 0.0)\n\n\n\n\nSubtract all of the measured flux from a given direction.\n\n\nThis can be used to remove RFI sources provided they have a known direction.\n\n\nsubsrc!(ms::MeasurementSet, sources::Vector{Source}, beam::BeamModel)\n\n\n\n\nRemove the list of sources from the measurement set.\n\n\nwritesources\n\n\nwritesources(filename, sources::Vector{Source})\n\n\n\n\nWrite the list of sources to the given location as a JSON file. These sources can be read back in again using the \nreadsources\n function.", 
            "title": "API"
        }, 
        {
            "location": "/external/#api", 
            "text": "ConstantBeam  ConstantBeam  : BeamModel  In this beam model, the Jones matrix is assumed to be unity in every direction.  DiagonalJonesMatrix  immutable DiagonalJonesMatrix  This type represents a Jones matrix that is diagonal.  These matrices are used to represent the complex gains of each antenna without accounting for the off-diagonal polarization leakage terms.  GainCalibration  immutable GainCalibration  : Calibration  This type stores the information for calibrating the electronic gains of the interferometer. That is, it stores complex gains and flags for each antenna, frequency channel, and polarization.  GainCalibration(Nant, Nfreq)  Create a calibration table for  Nant  antennas with  Nfreq  frequency channels where all the gains are initially set to unity.  HermitianJonesMatrix  immutable HermitianJonesMatrix  This type represents a Jones matrix that is Hermitian.  These matrices are useful for representing the $xx$, $xy$, $yx$, and $yy$ flux, because $xx$ and $yy$ are constrained to be real while $xy$ and $yx$ are complex conjugates.  JonesMatrix  immutable JonesMatrix  This type represents a 2x2 complex Jones matrix.    \\begin{pmatrix}     j_{xx} & j_{xy} \\\\\n    j_{yx} & j_{yy} \\\\\n\\end{pmatrix}    MeasurementSet  immutable MeasurementSet  This type is a wrapper around  CasaCore.Tables.Table  that is intended to simplify most of the common interactions between TTCal and measurement sets.  MeasurementSet(name)  Open the measurement set at the given location. Assorted quantities that are commonly used by TTCal are automatically loaded and stored in fields.  Memo178Beam  Memo178Beam  : BeamModel  This beam is based on the parametric fit to EM simulations presented in LWA memo 178 by Jayce Dowell.  [http://www.faculty.ece.vt.edu/swe/lwa/memo/lwa0178a.pdf]  MuellerMatrix  immutable MuellerMatrix  This type represents a Mueller matrix.  MuellerMatrix(J::JonesMatrix)  Create a Mueller matrix from the given Jones matrix.  Point  PolarizationCalibration  immutable PolarizationCalibration  : Calibration  This type stores the information for calibrating the polarization of the interferometer. That is, it stores Jones matrices and flags for each antenna and each frequency channel.  PolarizationCalibration(Nant, Nfreq)  Create a calibration table for  Nant  antennas with  Nfreq  frequency channels where all the Jones matrices are initially set to the identity matrix.  SineBeam  SineBeam  : BeamModel  This beam is azimuthally symmetric and independent of frequency. The gain of an individual dipole scales as $\\sin(elevation)^\\alpha$.  Source  immutable Source  This type represents a radio source.  Each source is composed of one or more components.  Spectrum  immutable Spectrum  These sources have a multi-component power-law spectrum such that:        \\log_{10} S = \\log_{10} S_0 + \\sum_{n=1}^N \\alpha_n \\log_{10}\\left(\\frac{\\nu}{\\nu_0}\\right)^n    where $S$ is a Stokes parameter, and $\\alpha_n$ is the list of spectral indices. At least one spectral index needs to be provided.  StokesVector  immutable StokesVector  This type represents a Stokes vector.    \\begin{pmatrix}     I \\\\\n    Q \\\\\n    U \\\\\n    V \\\\\n\\end{pmatrix}    applycal!  applycal!(ms::MeasurementSet, calibration::Calibration;\n          apply_to_corrected = false, force_imaging_columns = false)  Apply the calibration to the given measurement set.  Arguments:   ms  - the measurement set to which the calibration will be applied  calibration  - the calibration that will be applied   Keyword Arguments:   apply_to_corrected  - if this is set to true, the calibration will be     applied to the CORRECTED_DATA column instead of the DATA column  force_imaging_columns  - if this is set to true, the calibrated data     will be written to the CORRECTED_DATA column regardless of whether     or not the column already exists   corrupt!  corrupt!(data::Array{Complex64,3}, cal::Calibration, ant1, ant2)  Corrupt the model data as if it had been observed with an instrument with the given calibration.  corrupt!(data::Array{Complex64,3}, flags::Array{Bool,3},\n         cal::Calibration, ant1, ant2)  Corrupt the data as if it was observed with the given calibration.  fitvis  fitvis(ms::MeasurementSet, direction::Direction;\n       maxiter = 20, tolerance = 1e-3, minuvw = 0.0) -  l,m  Fit for the location of a point source near the given direction.  gaincal  gaincal(ms::MeasurementSet, sources::Vector{Source}, beam::BeamModel;\n        maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n        reference_antenna =  1x , force_imaging_columns = false)  Solve for the interferometer's electronic gains.  Arguments:   ms  - the measurement set from which to derive the calibration  sources  - the list of points sources to use as the sky model  beam  - the beam model   Keyword Arguments:   maxiter  - the maximum number of Runge-Kutta steps to take on each     frequency channel  tolerance  - the relative tolerance to use while checking to see if     more iterations are required  minuvw  - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure  reference_antenna  - a string containing the antenna number and polarization     whose phase will be chosen to be zero (eg. \"14y\" or \"62x\")  force_imaging_columns  - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist   genvis  genvis(ms::MeasurementSet, sources, beam::BeamModel)  Generate model visibilities for the given list of sources and the given beam model.  No gridding is performed, so the runtime of this naive algorithm scales as $O(N_{base} \\times N_{source})$.  getspec  getspec(data, flags, l, m, u, v, w, \u03bd, ant1, ant2) -  Vector{HermitianJonesMatrix}  Compute the spectrum of a source located at $(l,m)$ in all of the polarized correlation products.  getspec(ms::MeasurementSet, direction::Direction;\n        minuvw = 0.0) -  Vector{HermitianJonesMatrix}  This function extracts the spectrum in a given direction by means of an inverse discrete Fourier transform.  Note that no gridding is performed, so this does  not  use a fast Fourier transform. However, the inverse discrete Fourier transform  is  the least squares estimator for the flux in a given direction (if all baselines are weighted equally).  peel!  peel!{T :Calibration}(::Type{T},\n                      ms::MeasurementSet,\n                      sources::Vector{Source},\n                      beam::BeamModel;\n                      peeliter = 3,\n                      maxiter = 20,\n                      tolerance = 1e-3,\n                      minuvw = 0.0)  Peel the given list of sources from the measurement set.  The type supplied as the first argument determines the manner in which the sources are peeled:   PolarizationCalibration  - each source receives a full set of Jones matrices  GainCalibration  - each source receives a full set of complex gains  AmplitudeCalibration  - each source receives a full set of gain amplitudes   polcal  polcal(ms::MeasurementSet, sources::Vector{Source}, beam::BeamModel;\n       maxiter = 20, tolerance = 1e-3, minuvw = 0.0,\n       force_imaging_columns = false)  Solve for the polarization properties of the interferometer.  Arguments:   ms  - the measurement set from which to derive the calibration  sources  - the list of points sources to use as the sky model  beam  - the beam model   Keyword Arguments:   maxiter  - the maximum number of Runge-Kutta steps to take on each     frequency channel  tolerance  - the relative tolerance to use while checking to see if     more iterations are required  minuvw  - the minimum baseline length (measured in wavelengths) to be     used during the calibration procedure  force_imaging_columns  - if this is set to true, the MODEL_DATA column     will be created and populated with model visibilities even if it     doesn't already exist   readsources  readsources(filename) -  Vector{Source}  Read the list of point sources from the given JSON file. The format must be as follows:  [\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cas A ,\n         ra :  23h23m24s ,\n         dec :  58d48m54s ,\n         I : 555904.26,\n         freq : 1.0e6,\n         index : [-0.770]\n    },\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cyg A ,\n         ra :  19h59m28.35663s ,\n         dec :  +40d44m02.0970s ,\n         I : 49545.02,\n         freq : 1.0e6,\n         index : [+0.085,-0.178]\n    }\n]  Additional Stokes parameters may also be specified.  {\n    ...\n     I : 100\n     Q : 20\n     U : 3.14\n     V : -30\n    ...\n}  A right ascension and declination does not need to be specified if the name of the source is \"Sun\", \"Moon\", or \"Jupiter\". These sources will have their location automatically determined by CasaCore.  subsrc!  subsrc!(ms::MeasurementSet, dir::Direction; minuvw = 0.0)  Subtract all of the measured flux from a given direction.  This can be used to remove RFI sources provided they have a known direction.  subsrc!(ms::MeasurementSet, sources::Vector{Source}, beam::BeamModel)  Remove the list of sources from the measurement set.  writesources  writesources(filename, sources::Vector{Source})  Write the list of sources to the given location as a JSON file. These sources can be read back in again using the  readsources  function.", 
            "title": "API"
        }, 
        {
            "location": "/internal/", 
            "text": "Internal Documentation\n\n\nRK{N}\n\n\nThis singleton type is used to indicate which Runge-Kutta method should be used. For example, \nRK{4}\n tells us to use the RK4 method.\n\n\ncongruence_transform\n\n\ncongruence_transform(J::JonesMatrix, K::HermitianJonesMatrix) -\n J*K*J'\n\n\n\n\nCompute the congruence transformation of $K$ with respect to $J$:\n\n\n\n\n     K \\rightarrow JKJ^* \n\n\n\n\ndirection_cosines\n\n\ndirection_cosines(phase_dir::Direction{dir\nJ2000\n}, dir::Direction{dir\nJ2000\n}) -\n l,m\n\n\n\n\nCompute the direction cosines $(l,m)$ for the given direction with respect to the phase direction.\n\n\nfixphase!\n\n\nfixphase!(cal::Calibration, reference_antenna)\n\n\n\n\nSet the phase of the reference antenna and polarization to zero.\n\n\nArguments:\n\n\n\n\ncal\n - the calibration that will have its phase adjusted\n\n\nreference_antenna\n - a string containing the antenna number and polarization     whose phase will be chosen to be zero (eg. \"14y\" or \"62x\")\n\n\n\n\nflag_short_baselines!\n\n\nflag_short_baselines!(flags, minuvw, u, v, w, \u03bd)\n\n\n\n\nFlag all of the baselines whose length is less than \nminuvw\n wavelengths.\n\n\nThis is a common operation that can mitigate contamination by unmodeled diffuse emission.\n\n\nforce_to_horizon\n\n\nforce_to_horizon(l,m)\n\n\n\n\nThis function forces the coordinates $(l,m)$ to be above the horizon.\n\n\nAlthough this is a nasty hack, it is necessary for fitting some sources that are near the horizon.\n\n\nfringepattern\n\n\nfringepattern(\u03d5, \u0394\u03d5, N)\n\n\n\n\nCompute $\\exp(i(\\phi+n\\Delta\\phi))$ where $\\phi$, $\\Delta\\phi$, and $n = 1,\\ldots,N$ define an equally spaced grid of points.\n\n\nUsing the sine and cosine angle addition rules, you can define an iterative method such that you only need to compute sines and cosines for a single iteration.\n\n\nget_corrected_data\n\n\nget_corrected_data(ms::MeasurementSet)\n\n\n\n\nGet the CORRECTED_DATA column if it exists. Otherwise settle for the DATA column.\n\n\nget_flags\n\n\nget_flags(ms::MeasurementSet)\n\n\n\n\nGet the flags from the dataset, but this information is stored in multiple locations. Unify all these flags before returning.\n\n\ninvert\n\n\ninvert(cal::Calibration)\n\n\n\n\nReturns the inverse of the given calibration. The Jones matrix $J$ of each antenna is set to $J^{-1}$.\n\n\nj2000_radec\n\n\nj2000_radec(frame::ReferenceFrame, component::Component) -\n ra,dec\n\n\n\n\nCompute the J2000 right ascension and declination of the component (in radians).\n\n\nlatlong_to_utm\n\n\nlatlong_to_utm(zone, latitude, longitude)\n\n\n\n\nConvert the latitude and longitude (both in degrees) to an easting and a northing (both in meters).\n\n\nThis function is entirely based on the \nUniversal Transverse Mercator coordinate system\n Wikipedia page.\n\n\nlinear\n\n\nlinear(stokes::StokesVector) -\n HermitianJonesMatrix\n\n\n\n\nTake the set of Stokes parameters $(I,Q,U,V)$ and convert it to the set of correlations $(xx,xy,yx,yy)$.\n\n\nlocal_azel\n\n\nlocal_azel(frame::ReferenceFrame, component::Component) -\n az,el\n\n\n\n\nCompute the local azimuth and elevation of the component (in radians).\n\n\nmakesquare\n\n\nmakesquare(data, flags, ant1, ant2)\n\n\n\n\nPack the data into a square Hermitian matrix such that the data is ordered as follows:\n\n\n\n\n     \\begin{pmatrix}         V_{11} & V_{12} & V_{13} &        & \\\\\n        V_{21} & V_{22} & V_{23} &        & \\\\\n        V_{31} & V_{32} & V_{33} &        & \\\\\n               &        &        & \\ddots & \\\\\n    \\end{pmatrix} \n\n\n\n\nFlagged correlations and autocorrelations are set to zero.\n\n\nrkstep\n\n\nTake a Runge-Kutta step. * \nstep(x,args...)\n must return the list of steps to take from the given location \nx\n * \nrk\n is the order of the Runge-Kutta method to use (eg. \nRK4\n) * \nx\n is the starting location * \nargs\n is simply passed on as the second argument to \nstep\n\n\nstefcal_step\n\n\nstefcal_step(input,data,model) -\n step\n\n\n\n\nGiven the \ndata\n and \nmodel\n visibilities, and the current guess for the Jones matrices, solve for \nstep\n such that the new value of the Jones matrices is \ninput+step\n.\n\n\nThe update step is defined such that the new value of the Jones matrices minimizes\n\n\n\n\n     \\sum_{i,j}\\|V_{i,j} - G_i M_{i,j} G_{j,new}^*\\|^2$, \n\n\n\n\nwhere $i$ and $j$ label the antennas, $V$ labels the measured visibilities, $M$ labels the model visibilities, and $G$ labels the Jones matrices.\n\n\nReferences:\n\n\n\n\nMichell, D. et al. 2008, JSTSP, 2, 5.\n\n\nSalvini, S. \n Wijnholds, S. 2014, A\nA, 571, 97.\n\n\n\n\nstokes\n\n\nstokes(correlations::HermitianJonesMatrix) -\n StokesVector\n\n\n\n\nTake the set of correlations $(xx,xy,yx,yy)$ and convert it to the set of Stokes parameters $(I,Q,U,V)$.\n\n\nutm_to_latlong\n\n\nutm_to_latlong(zone, easting, northing,\n               hemisphere = north)\n\n\n\n\nConvert the easting and northing (both in meters) to a latitude and longitude (both in degrees).\n\n\nThis function is entirely based on the \nUniversal Transverse Mercator coordinate system\n Wikipedia page.", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/internal/#internal-documentation", 
            "text": "RK{N}  This singleton type is used to indicate which Runge-Kutta method should be used. For example,  RK{4}  tells us to use the RK4 method.  congruence_transform  congruence_transform(J::JonesMatrix, K::HermitianJonesMatrix) -  J*K*J'  Compute the congruence transformation of $K$ with respect to $J$:        K \\rightarrow JKJ^*    direction_cosines  direction_cosines(phase_dir::Direction{dir J2000 }, dir::Direction{dir J2000 }) -  l,m  Compute the direction cosines $(l,m)$ for the given direction with respect to the phase direction.  fixphase!  fixphase!(cal::Calibration, reference_antenna)  Set the phase of the reference antenna and polarization to zero.  Arguments:   cal  - the calibration that will have its phase adjusted  reference_antenna  - a string containing the antenna number and polarization     whose phase will be chosen to be zero (eg. \"14y\" or \"62x\")   flag_short_baselines!  flag_short_baselines!(flags, minuvw, u, v, w, \u03bd)  Flag all of the baselines whose length is less than  minuvw  wavelengths.  This is a common operation that can mitigate contamination by unmodeled diffuse emission.  force_to_horizon  force_to_horizon(l,m)  This function forces the coordinates $(l,m)$ to be above the horizon.  Although this is a nasty hack, it is necessary for fitting some sources that are near the horizon.  fringepattern  fringepattern(\u03d5, \u0394\u03d5, N)  Compute $\\exp(i(\\phi+n\\Delta\\phi))$ where $\\phi$, $\\Delta\\phi$, and $n = 1,\\ldots,N$ define an equally spaced grid of points.  Using the sine and cosine angle addition rules, you can define an iterative method such that you only need to compute sines and cosines for a single iteration.  get_corrected_data  get_corrected_data(ms::MeasurementSet)  Get the CORRECTED_DATA column if it exists. Otherwise settle for the DATA column.  get_flags  get_flags(ms::MeasurementSet)  Get the flags from the dataset, but this information is stored in multiple locations. Unify all these flags before returning.  invert  invert(cal::Calibration)  Returns the inverse of the given calibration. The Jones matrix $J$ of each antenna is set to $J^{-1}$.  j2000_radec  j2000_radec(frame::ReferenceFrame, component::Component) -  ra,dec  Compute the J2000 right ascension and declination of the component (in radians).  latlong_to_utm  latlong_to_utm(zone, latitude, longitude)  Convert the latitude and longitude (both in degrees) to an easting and a northing (both in meters).  This function is entirely based on the  Universal Transverse Mercator coordinate system  Wikipedia page.  linear  linear(stokes::StokesVector) -  HermitianJonesMatrix  Take the set of Stokes parameters $(I,Q,U,V)$ and convert it to the set of correlations $(xx,xy,yx,yy)$.  local_azel  local_azel(frame::ReferenceFrame, component::Component) -  az,el  Compute the local azimuth and elevation of the component (in radians).  makesquare  makesquare(data, flags, ant1, ant2)  Pack the data into a square Hermitian matrix such that the data is ordered as follows:        \\begin{pmatrix}         V_{11} & V_{12} & V_{13} &        & \\\\\n        V_{21} & V_{22} & V_{23} &        & \\\\\n        V_{31} & V_{32} & V_{33} &        & \\\\\n               &        &        & \\ddots & \\\\\n    \\end{pmatrix}    Flagged correlations and autocorrelations are set to zero.  rkstep  Take a Runge-Kutta step. *  step(x,args...)  must return the list of steps to take from the given location  x  *  rk  is the order of the Runge-Kutta method to use (eg.  RK4 ) *  x  is the starting location *  args  is simply passed on as the second argument to  step  stefcal_step  stefcal_step(input,data,model) -  step  Given the  data  and  model  visibilities, and the current guess for the Jones matrices, solve for  step  such that the new value of the Jones matrices is  input+step .  The update step is defined such that the new value of the Jones matrices minimizes        \\sum_{i,j}\\|V_{i,j} - G_i M_{i,j} G_{j,new}^*\\|^2$,    where $i$ and $j$ label the antennas, $V$ labels the measured visibilities, $M$ labels the model visibilities, and $G$ labels the Jones matrices.  References:   Michell, D. et al. 2008, JSTSP, 2, 5.  Salvini, S.   Wijnholds, S. 2014, A A, 571, 97.   stokes  stokes(correlations::HermitianJonesMatrix) -  StokesVector  Take the set of correlations $(xx,xy,yx,yy)$ and convert it to the set of Stokes parameters $(I,Q,U,V)$.  utm_to_latlong  utm_to_latlong(zone, easting, northing,\n               hemisphere = north)  Convert the easting and northing (both in meters) to a latitude and longitude (both in degrees).  This function is entirely based on the  Universal Transverse Mercator coordinate system  Wikipedia page.", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "", 
            "title": "Contributing"
        }, 
        {
            "location": "/docs/", 
            "text": "Building this Website\n\n\nThis website is built using \nMkDocs\n and hosted\non \nGithub Pages\n. Building and deploying the\ndocumentation will require a little bit of setup.\n\n\n\n\nRun \npip install --user mkdocs\n to obtain MkDocs.\n\n\nRun \npip install --user python-markdown-math\n to obtain the markdown\n   extension that allows LaTeX-style math.\n\n\nRun \ndocs/gendocs.jl\n to extract the documentation from the Julia\n   source code into the relevant Markdown files.\n\n\nRun \nmkdocs serve\n and navigate your web browser to\n   \nhttp://127.0.0.1:8000\n\n   to check that everything looks correct.\n\n\nRun \nmkdocs gh-deploy\n to deploy the new documentation to Github Pages.\n\n\nCommit all your changes.", 
            "title": "Building this Website"
        }, 
        {
            "location": "/docs/#building-this-website", 
            "text": "This website is built using  MkDocs  and hosted\non  Github Pages . Building and deploying the\ndocumentation will require a little bit of setup.   Run  pip install --user mkdocs  to obtain MkDocs.  Run  pip install --user python-markdown-math  to obtain the markdown\n   extension that allows LaTeX-style math.  Run  docs/gendocs.jl  to extract the documentation from the Julia\n   source code into the relevant Markdown files.  Run  mkdocs serve  and navigate your web browser to\n    http://127.0.0.1:8000 \n   to check that everything looks correct.  Run  mkdocs gh-deploy  to deploy the new documentation to Github Pages.  Commit all your changes.", 
            "title": "Building this Website"
        }
    ]
}