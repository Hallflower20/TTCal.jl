{
    "docs": [
        {
            "location": "/", 
            "text": "TTCal\n\u00b6\n\n\nTTCal is a calibration routine developed for the OVRO LWA.\n\n\nOverview\n\u00b6\n\n\nThe standard procedure for phase calibrating a radio interferometer\nusually involves slewing a small number of large dishes to stare at\na known point source. A point source at the phase center of the\ninterferometer has zero phase on all baselines, so phase calibration\nessentially amounts to zeroing the phase on all baselines.\n\n\nLow frequency telescopes (\n300 MHz) tend to occupy an entirely different\nregion of phase space. That is they are usually composed of numerous\ncheap dipole antennas with very broad beams (\nLOFAR\n,\n\nMWA\n). Furthermore, the low frequency sky\nis corrupted by propagation through the ionosphere. Until the field matures,\nthe demand for a new and effective calibration technique\nis best met by a simple, adaptable, and relatively fast software package.\nThis is why I wrote TTCal.\n\n\n\n\n\n\n\n\nFigure 1. An OVRO LWA snapshot image made using data calibrated exclusively with TTCal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started\n\u00b6\n\n\nTTCal requires version 0.4 of the \nJulia\n programming\nlanguage. Julia is a dynamic language designed for scientific computing with\na just-in-time compiler based on \nLLVM\n. The syntax\nshould be familiar to users of \nMatlab\n\nand \nPython\n, but Python users should be aware\nthat the first element of an array is accessed with \nx[1]\n.\n\n\nOnce Julia is installed, the REPL (read-eval-print loop) can be started by\ntyping \njulia\n from the command line. Try running the following examples:\n\n\njulia\n \n1\n+\n1\n\n\n2\n\n\n\njulia\n \nfor\n \ni\n \n=\n \n1\n:\n3\n\n           \nprintln\n(\nrand\n())\n\n       \nend\n\n\n0.8165122957881887\n\n\n0.8315752097289137\n\n\n0.6558156424738537\n\n\n\n\n\n\nTTCal depends on the \nCasaCore.jl\n\npackage, which is a Julia wrapper of the \ncasacore\n\nlibrary. It is used to interface with measurement sets and perform\ncoordinate conversions.\n\n\nTo install TTCal run:\n\n\njulia\n \nPkg\n.\nupdate\n()\n\n\n\n# Get the latest version of CasaCore.jl and build the wrapper\n\n\njulia\n \nPkg\n.\nclone\n(\nCasaCore\n)\n\n\njulia\n \nPkg\n.\nbuild\n(\nCasaCore\n)\n\n\n\n# Get the latest version of TTCal\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/mweastwood/TTCal.jl.git\n)\n\n\njulia\n \nPkg\n.\ntest\n(\nTTCal\n)\n\n\n\n\n\n\nIf all the tests pass, you are ready to begin using TTCal.\n\n\nWhile the most powerful interface to TTCal involves writing small\nJulia scripts, a limited command line interface is available.\nSimply add the \nttcal.jl\n file to your \nPATH\n environment variable.\nYou can see the list of available commands by running:\n\n\n$ ttcal.jl --help\nusage: ttcal.jl \n[\n-h\n]\n \n{\ngaincal\n|\npolcal\n|\npeel\n|\napplycal\n}\n\n\nA calibration routine developed \nfor\n the OVRO LWA.\n\ncommands:\n  gaincal     Solve \nfor\n a gain calibration.\n  polcal      Solve \nfor\n a polarization calibration.\n  peel        Peel sources from the dataset.\n  applycal    Apply a calibration.\n\noptional arguments:\n  -h, --help  show this \nhelp\n message and \nexit\n\n\n\n\n\n\nNote that every time Julia is restarted there is overhead\nassociated with reloading and recompiling the code. While\nJulia version 0.4 introduced code caching to help mitigate this,\nrunning TTCal will always be faster from a Julia script\nthan from the command line.\n\n\n\n\nNote\n\n\nTTCal expects data to be provided as a measurement set. Furthermore each\nmeasurement set must contain only a single spectral window and a single time integration.\n\n\n\n\nBugs, Errors, and Questions (oh my!)\n\u00b6\n\n\nIf you encounter any problems or errors, please\n\nopen an issue\n\non Github. Known problems are listed as\n\nopen issues\n.\n\n\nIf you have any questions after reading through this documentation\nlet Michael know by\n\nopening an issue\n\non Github.", 
            "title": "Home"
        }, 
        {
            "location": "/#ttcal", 
            "text": "TTCal is a calibration routine developed for the OVRO LWA.", 
            "title": "TTCal"
        }, 
        {
            "location": "/#overview", 
            "text": "The standard procedure for phase calibrating a radio interferometer\nusually involves slewing a small number of large dishes to stare at\na known point source. A point source at the phase center of the\ninterferometer has zero phase on all baselines, so phase calibration\nessentially amounts to zeroing the phase on all baselines.  Low frequency telescopes ( 300 MHz) tend to occupy an entirely different\nregion of phase space. That is they are usually composed of numerous\ncheap dipole antennas with very broad beams ( LOFAR , MWA ). Furthermore, the low frequency sky\nis corrupted by propagation through the ionosphere. Until the field matures,\nthe demand for a new and effective calibration technique\nis best met by a simple, adaptable, and relatively fast software package.\nThis is why I wrote TTCal.     Figure 1. An OVRO LWA snapshot image made using data calibrated exclusively with TTCal.", 
            "title": "Overview"
        }, 
        {
            "location": "/#getting-started", 
            "text": "TTCal requires version 0.4 of the  Julia  programming\nlanguage. Julia is a dynamic language designed for scientific computing with\na just-in-time compiler based on  LLVM . The syntax\nshould be familiar to users of  Matlab \nand  Python , but Python users should be aware\nthat the first element of an array is accessed with  x[1] .  Once Julia is installed, the REPL (read-eval-print loop) can be started by\ntyping  julia  from the command line. Try running the following examples:  julia   1 + 1  2  julia   for   i   =   1 : 3 \n            println ( rand ()) \n        end  0.8165122957881887  0.8315752097289137  0.6558156424738537   TTCal depends on the  CasaCore.jl \npackage, which is a Julia wrapper of the  casacore \nlibrary. It is used to interface with measurement sets and perform\ncoordinate conversions.  To install TTCal run:  julia   Pkg . update ()  # Get the latest version of CasaCore.jl and build the wrapper  julia   Pkg . clone ( CasaCore )  julia   Pkg . build ( CasaCore )  # Get the latest version of TTCal  julia   Pkg . clone ( https://github.com/mweastwood/TTCal.jl.git )  julia   Pkg . test ( TTCal )   If all the tests pass, you are ready to begin using TTCal.  While the most powerful interface to TTCal involves writing small\nJulia scripts, a limited command line interface is available.\nSimply add the  ttcal.jl  file to your  PATH  environment variable.\nYou can see the list of available commands by running:  $ ttcal.jl --help\nusage: ttcal.jl  [ -h ]   { gaincal | polcal | peel | applycal } \n\nA calibration routine developed  for  the OVRO LWA.\n\ncommands:\n  gaincal     Solve  for  a gain calibration.\n  polcal      Solve  for  a polarization calibration.\n  peel        Peel sources from the dataset.\n  applycal    Apply a calibration.\n\noptional arguments:\n  -h, --help  show this  help  message and  exit   Note that every time Julia is restarted there is overhead\nassociated with reloading and recompiling the code. While\nJulia version 0.4 introduced code caching to help mitigate this,\nrunning TTCal will always be faster from a Julia script\nthan from the command line.   Note  TTCal expects data to be provided as a measurement set. Furthermore each\nmeasurement set must contain only a single spectral window and a single time integration.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#bugs-errors-and-questions-oh-my", 
            "text": "If you encounter any problems or errors, please open an issue \non Github. Known problems are listed as open issues .  If you have any questions after reading through this documentation\nlet Michael know by opening an issue \non Github.", 
            "title": "Bugs, Errors, and Questions (oh my!)"
        }, 
        {
            "location": "/cookbook/", 
            "text": "Cookbook\n\u00b6\n\n\nGain Calibration\n\u00b6\n\n\nRunning from a Julia script\n\n\nusing\n \nCasaCore\n.\nTables\n\n\nusing\n \nTTCal\n\n\n\n# open the measurement set and read the DATA column\n\n\nms\n \n=\n \nTable\n(\ndata.ms\n)\n\n\nvisibilities\n \n=\n \nTTCal\n.\nget_data\n(\nms\n)\n\n\n\n# read metadata from the measurement set and choose a beam model\n\n\nbeam\n \n=\n \nSineBeam\n()\n\n\nmeta\n \n=\n \ncollect_metadata\n(\nms\n,\n \nbeam\n)\n\n\n\n# read the sky model\n\n\nsources\n \n=\n \nreadsources\n(\nsources.json\n)\n\n\n\n# solve for the calibration\n\n\ncal\n \n=\n \ngaincal\n(\nvisibilities\n,\n \nmeta\n,\n \nsources\n)\n\n\n\n# apply the calibration to the visibilities\n\n\napplycal!\n(\nvisibilities\n,\n \nmeta\n,\n \ncal\n)\n\n\n\n# write the corrected visibilities to the CORRECTED_DATA column\n\n\nTTCal\n.\nset_corrected_data!\n(\nms\n,\n \nvisibilities\n)\n\n\n\n# release the lock on the measurement set so that other processes can use it\n\n\nunlock\n(\nms\n)\n\n\n\n\n\n\nRunning from the command line\n\n\nttcal.jl gaincal --input data.ms --output calibration.jld --sources sources.json\nttcal.jl applycal --input data.ms --calibration calibration.jld", 
            "title": "Cookbook"
        }, 
        {
            "location": "/cookbook/#cookbook", 
            "text": "", 
            "title": "Cookbook"
        }, 
        {
            "location": "/cookbook/#gain-calibration", 
            "text": "Running from a Julia script  using   CasaCore . Tables  using   TTCal  # open the measurement set and read the DATA column  ms   =   Table ( data.ms )  visibilities   =   TTCal . get_data ( ms )  # read metadata from the measurement set and choose a beam model  beam   =   SineBeam ()  meta   =   collect_metadata ( ms ,   beam )  # read the sky model  sources   =   readsources ( sources.json )  # solve for the calibration  cal   =   gaincal ( visibilities ,   meta ,   sources )  # apply the calibration to the visibilities  applycal! ( visibilities ,   meta ,   cal )  # write the corrected visibilities to the CORRECTED_DATA column  TTCal . set_corrected_data! ( ms ,   visibilities )  # release the lock on the measurement set so that other processes can use it  unlock ( ms )   Running from the command line  ttcal.jl gaincal --input data.ms --output calibration.jld --sources sources.json\nttcal.jl applycal --input data.ms --calibration calibration.jld", 
            "title": "Gain Calibration"
        }, 
        {
            "location": "/calibration/", 
            "text": "Calibration\n\u00b6\n\n\nCalibration is necessary to remove instrumental effects on the measured visibilities\nprior to imaging. The process of calibration can generally be divided into two categories:\n\n\n\n\nDirection independent calibration\n\n\nDirection dependent calibration\n\n\n\n\nDirection independent calibration attempts to remove instrumental effects arising from\nthe electronics between the antenna and the correlator. For example amplifiers and cables\ncan add to the amplitude and phase of the voltage respectively.\nWhereas direction dependent calibration attempts to remove instrumental effects arising from\nthe antenna beam pattern and propagation through the ionosphere.\n\n\nBoth types of calibration can be viewed as trying to solve for best Jones matrices $J$\nin the following equation\n\n\n\n\n\n    V_{ij}^\\text{measured} = J_i V_{ij}^\\text{model} J_j^* + \\text{noise},\n\n\n\n\n\nwhere $V_{ij}$ is a 2x2 matrix containing the \nxx\n, \nxy\n, \nyx\n, and \nyy\n correlations\nbetween antenna $i$ and antenna $j$, and $J_i$ is the Jones matrix associated with antenna $i$.\nIn direction independent calibration the Jones matrices are a function of frequency only.\nIn direction dependent calibration the Jones matrices are a function of frequency and direction.\n\n\nIterative Least Squares\n\u00b6\n\n\nTTCal uses the method of iterative least squares independently described by\n\nMitchell et al. 2008\n and\n\nSalvini \n Wijnholds 2014\n\nto solve for the Jones matrices.\nGiven a set of model visibilities we seek to minimize\n\n\n\n\n\n    \\sum_{ij} \\left\\| V_{ij}^\\text{measured} - J_i V_{ij}^\\text{model} J_j^* \\right\\|^2\n\n\n\n\n\nIf $J_i$ is assumed to be constant, the least squares solution for $J_j^*$ is\n\n\n\n\n\n    J_j^* = \\frac{\\sum_i \\left(J_i V_{ij}^\\text{model}\\right)^* V_{ij}^\\text{measured}}\n                 {\\sum_i \\left\\|J_i V_{ij}^\\text{model}\\right\\|^2}.\n\n\n\n\n\nThis can be computed rapidly but iterating will tend to oscillate around the\nsolution to the original optimization problem. These oscillations need to be damped\nfor rapid convergence. TTCal damps these oscillations by using Runge-Kutta steps.\n\n\nGain Calibration\n\u00b6\n\n\nWith gain calibration TTCal will solve for a set of diagonal Jones matrices\n(one per antenna and frequency channel). The diagonal terms of the Jones matrix\nrepresent the complex gain (amplitude and phase) of each antenna.\n\n\nSee the \ncookbook\n for an example gain calibration on an LWA dataset.", 
            "title": "Calibration"
        }, 
        {
            "location": "/calibration/#calibration", 
            "text": "Calibration is necessary to remove instrumental effects on the measured visibilities\nprior to imaging. The process of calibration can generally be divided into two categories:   Direction independent calibration  Direction dependent calibration   Direction independent calibration attempts to remove instrumental effects arising from\nthe electronics between the antenna and the correlator. For example amplifiers and cables\ncan add to the amplitude and phase of the voltage respectively.\nWhereas direction dependent calibration attempts to remove instrumental effects arising from\nthe antenna beam pattern and propagation through the ionosphere.  Both types of calibration can be viewed as trying to solve for best Jones matrices $J$\nin the following equation   \n    V_{ij}^\\text{measured} = J_i V_{ij}^\\text{model} J_j^* + \\text{noise},   where $V_{ij}$ is a 2x2 matrix containing the  xx ,  xy ,  yx , and  yy  correlations\nbetween antenna $i$ and antenna $j$, and $J_i$ is the Jones matrix associated with antenna $i$.\nIn direction independent calibration the Jones matrices are a function of frequency only.\nIn direction dependent calibration the Jones matrices are a function of frequency and direction.", 
            "title": "Calibration"
        }, 
        {
            "location": "/calibration/#iterative-least-squares", 
            "text": "TTCal uses the method of iterative least squares independently described by Mitchell et al. 2008  and Salvini   Wijnholds 2014 \nto solve for the Jones matrices.\nGiven a set of model visibilities we seek to minimize   \n    \\sum_{ij} \\left\\| V_{ij}^\\text{measured} - J_i V_{ij}^\\text{model} J_j^* \\right\\|^2   If $J_i$ is assumed to be constant, the least squares solution for $J_j^*$ is   \n    J_j^* = \\frac{\\sum_i \\left(J_i V_{ij}^\\text{model}\\right)^* V_{ij}^\\text{measured}}\n                 {\\sum_i \\left\\|J_i V_{ij}^\\text{model}\\right\\|^2}.   This can be computed rapidly but iterating will tend to oscillate around the\nsolution to the original optimization problem. These oscillations need to be damped\nfor rapid convergence. TTCal damps these oscillations by using Runge-Kutta steps.", 
            "title": "Iterative Least Squares"
        }, 
        {
            "location": "/calibration/#gain-calibration", 
            "text": "With gain calibration TTCal will solve for a set of diagonal Jones matrices\n(one per antenna and frequency channel). The diagonal terms of the Jones matrix\nrepresent the complex gain (amplitude and phase) of each antenna.  See the  cookbook  for an example gain calibration on an LWA dataset.", 
            "title": "Gain Calibration"
        }, 
        {
            "location": "/sourcemodel/", 
            "text": "Sky Models\n\u00b6\n\n\nPoint Sources\n\u00b6\n\n\nFor the OVRO LWA the two most important point sources for calibration are\n\nCas A\n and\n\nCyg A\n, which are the two brightest\nsources on the sky. The optimal time to solve for a calibration is when both\nof these sources are above the horizon.\n\n\nCurrently TTCal expects the sky model to be specified as a list of point sources.\nThis is accomplished by listing the sources in a \nJSON\n file.\nFor example the following file defines a sky model consisting of Cas A and Cyg A\nusing the published spectra for \nBaars et al. 1977\n.\n\n\n[\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCas A\n,\n        \nra\n: \n23h23m24s\n,\n        \ndec\n: \n58d48m54s\n,\n        \nI\n: 555904.26,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [-0.770]\n    },\n    {\n        \nref\n: \nBaars et al. 1977\n,\n        \nname\n: \nCyg A\n,\n        \nra\n: \n19h59m28.35663s\n,\n        \ndec\n: \n+40d44m02.0970s\n,\n        \nI\n: 49545.02,\n        \nQ\n: 0.0,\n        \nU\n: 0.0,\n        \nV\n: 0.0,\n        \nfreq\n: 1.0e6,\n        \nindex\n: [+0.085,-0.178]\n    }\n]\n\n\n\n\n\nFields:\n\n\n\n\nref\n is not used by TTCal, but is intended to be a record of the origin\n  of the information used to define the source\n\n\nname\n is the name of the source\n\n\nra\n and \ndec\n define the J2000 location of the source\n\n\nI\n, \nQ\n, \nU\n, and \nV\n define the Stokes parameters (in Jy) at the frequency \nfreq\n (in Hz)\n  \nQ\n, \nU\n, and \nV\n are optional and will be assumed to be zero if they are not given\n\n\nindex\n defines the spectral index of the source (and higher order terms)\n\n\n\n\nHigher order terms are defined such that\n\n\n\n\n\n    \\log_{10} I = \\log_{10} I_0 + \\sum_{n=1}^N \\alpha_n \\log_{10}\\left(\\frac{\\nu}{\\nu_0}\\right)^n\n\n\n\n\n\nwhere $I_0$ is the Stokes-I flux at the reference frequency and $\\alpha_n$ represents\nthe values contained in \nindex\n.\n\n\n\n\nNote\n\n\nThe Sun, the Moon, and Jupiter are special cases. These solar system objects do not\nneed to have their position specified. TTCal will automatically determine their\nlocation based on the current time. This works based on the name of the source.\nIf you name a source \nSun\n, \nMoon\n, or \nJupiter\n it will be placed at the\ncorrect location.\n\n\n\n\nGaussian Sources\n\u00b6\n\n\nSupport for Gaussian sources is coming!\n\n\nNear-Field Sources\n\u00b6\n\n\nExperimental support for near-field sources is currently available in the latest version\nof TTCal. Because this is an experimental feature it is not yet very easy to use.\n\n\nDiffuse Emission\n\u00b6\n\n\nDiffuse emission is currently not supported within TTCal. Eventual support is on the\nhorizon.", 
            "title": "Sky Models"
        }, 
        {
            "location": "/sourcemodel/#sky-models", 
            "text": "", 
            "title": "Sky Models"
        }, 
        {
            "location": "/sourcemodel/#point-sources", 
            "text": "For the OVRO LWA the two most important point sources for calibration are Cas A  and Cyg A , which are the two brightest\nsources on the sky. The optimal time to solve for a calibration is when both\nof these sources are above the horizon.  Currently TTCal expects the sky model to be specified as a list of point sources.\nThis is accomplished by listing the sources in a  JSON  file.\nFor example the following file defines a sky model consisting of Cas A and Cyg A\nusing the published spectra for  Baars et al. 1977 .  [\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cas A ,\n         ra :  23h23m24s ,\n         dec :  58d48m54s ,\n         I : 555904.26,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [-0.770]\n    },\n    {\n         ref :  Baars et al. 1977 ,\n         name :  Cyg A ,\n         ra :  19h59m28.35663s ,\n         dec :  +40d44m02.0970s ,\n         I : 49545.02,\n         Q : 0.0,\n         U : 0.0,\n         V : 0.0,\n         freq : 1.0e6,\n         index : [+0.085,-0.178]\n    }\n]  Fields:   ref  is not used by TTCal, but is intended to be a record of the origin\n  of the information used to define the source  name  is the name of the source  ra  and  dec  define the J2000 location of the source  I ,  Q ,  U , and  V  define the Stokes parameters (in Jy) at the frequency  freq  (in Hz)\n   Q ,  U , and  V  are optional and will be assumed to be zero if they are not given  index  defines the spectral index of the source (and higher order terms)   Higher order terms are defined such that   \n    \\log_{10} I = \\log_{10} I_0 + \\sum_{n=1}^N \\alpha_n \\log_{10}\\left(\\frac{\\nu}{\\nu_0}\\right)^n   where $I_0$ is the Stokes-I flux at the reference frequency and $\\alpha_n$ represents\nthe values contained in  index .   Note  The Sun, the Moon, and Jupiter are special cases. These solar system objects do not\nneed to have their position specified. TTCal will automatically determine their\nlocation based on the current time. This works based on the name of the source.\nIf you name a source  Sun ,  Moon , or  Jupiter  it will be placed at the\ncorrect location.", 
            "title": "Point Sources"
        }, 
        {
            "location": "/sourcemodel/#gaussian-sources", 
            "text": "Support for Gaussian sources is coming!", 
            "title": "Gaussian Sources"
        }, 
        {
            "location": "/sourcemodel/#near-field-sources", 
            "text": "Experimental support for near-field sources is currently available in the latest version\nof TTCal. Because this is an experimental feature it is not yet very easy to use.", 
            "title": "Near-Field Sources"
        }, 
        {
            "location": "/sourcemodel/#diffuse-emission", 
            "text": "Diffuse emission is currently not supported within TTCal. Eventual support is on the\nhorizon.", 
            "title": "Diffuse Emission"
        }, 
        {
            "location": "/beammodel/", 
            "text": "Beam Models\n\u00b6\n\n\nIn TTCal, a beam model is a function that takes a frequency (measured in Hz), an azimuth,\nand an elevation (both measured in radians) and returns a Jones matrix. This definition\nis only workable for zenith-pointing instruments like the OVRO LWA (for which TTCal was\ndeveloped).\n\n\n\n\n\n    \\text{beam model}: (\\nu, {\\rm az}, {\\rm el}) \\mapsto J\n\n\n\n\n\nBeam models are used during model visibility generation to account for attenuation,\npolarization leakage, and other instrumental effects. This is accomplished by using a\n\ncongruence transform\n.\n\n\n\n\n\n    V_\\text{corrupted model} = J V_\\text{pristine model} J^*,\n\n\n\n\n\nwhere $V$ is a 2x2 matrix containing the \nxx\n, \nxy\n, \nyx\n, and \nyy\n model visibilities.\n\n\nThe available beam models are listed below.\n\n\nConstant Beam\n\u00b6\n\n\nThe \nconstant beam\n simply assumes the Jones matrix is the identity at every frequency\nand in every direction. It goes without saying that this beam model is not realistic\n(especially away from zenith), but it can be useful.\nFor example if the flux of a source has already been attenuated by a beam model, you\nshould use the constant beam to prevent TTCal applying a second beam model.\n\n\nUse \nttcal.jl ... --beam constant ...\n to select the constant beam model from the\ncommand line or use \nbeam = ConstantBeam()\n from within a Julia script.\n\n\nSine Beam\n\u00b6\n\n\nAlso known as \nye olde beam model\n, this beam model has the antenna gains\nproportional to $\\sin({\\rm el})^\\alpha$, where $\\alpha$ is set to $1.6$ by default.\nThis is a surprisingly good first-order approximation to the LWA beam, but it\ndoes not include any frequency dependence.\n\n\n\n\n\n    J = \\begin{pmatrix}\n        \\sin({\\rm el})^{\\alpha/2} && 0 \\\\\n        0 && \\sin({\\rm el})^{\\alpha/2} \\\\\n    \\end{pmatrix}\n\n\n\n\n\nUse \nttcal.jl ... --beam sine ...\n to select the sine beam model (with $\\alpha = 1.6$)\nfrom the command line or use \nbeam = SineBeam(\u03b1)\n from within a Julia script.\n\n\nLWA Memo 178 Beam\n\u00b6\n\n\nAn even better approximation of the LWA beam comes from the LWA Memo Series.\n\nLWA Memo 178\n by\nJayce Dowell does a parametric fit to the results of EM simulations of the\nantennas.\n\n\nThe dipole gain is modeled as\n\n\n\n\n\n    p(\\theta) = \\left[1-\\left(\\frac{\\theta}{\\pi/2}\\right)^\\alpha\\right]\\cos^\\beta\\theta\n              + \\gamma\\left(\\frac{\\theta}{\\pi/2}\\right)\\cos^\\delta\\theta,\n\n\n\n\n\nwhere $\\theta$ is the zenith angle, and $\\alpha$, $\\beta$, $\\gamma$, and $\\delta$ are\nparameters that were fit for in the E- and H-planes of the dipole.\n\n\nUse \nttcal.jl ... --beam memo178 ...\n to select the LWA Memo 178 beam model from the\ncommand line or use \nbeam = Memo178Beam()\n from within a Julia script.", 
            "title": "Beam Models"
        }, 
        {
            "location": "/beammodel/#beam-models", 
            "text": "In TTCal, a beam model is a function that takes a frequency (measured in Hz), an azimuth,\nand an elevation (both measured in radians) and returns a Jones matrix. This definition\nis only workable for zenith-pointing instruments like the OVRO LWA (for which TTCal was\ndeveloped).   \n    \\text{beam model}: (\\nu, {\\rm az}, {\\rm el}) \\mapsto J   Beam models are used during model visibility generation to account for attenuation,\npolarization leakage, and other instrumental effects. This is accomplished by using a congruence transform .   \n    V_\\text{corrupted model} = J V_\\text{pristine model} J^*,   where $V$ is a 2x2 matrix containing the  xx ,  xy ,  yx , and  yy  model visibilities.  The available beam models are listed below.", 
            "title": "Beam Models"
        }, 
        {
            "location": "/beammodel/#constant-beam", 
            "text": "The  constant beam  simply assumes the Jones matrix is the identity at every frequency\nand in every direction. It goes without saying that this beam model is not realistic\n(especially away from zenith), but it can be useful.\nFor example if the flux of a source has already been attenuated by a beam model, you\nshould use the constant beam to prevent TTCal applying a second beam model.  Use  ttcal.jl ... --beam constant ...  to select the constant beam model from the\ncommand line or use  beam = ConstantBeam()  from within a Julia script.", 
            "title": "Constant Beam"
        }, 
        {
            "location": "/beammodel/#sine-beam", 
            "text": "Also known as  ye olde beam model , this beam model has the antenna gains\nproportional to $\\sin({\\rm el})^\\alpha$, where $\\alpha$ is set to $1.6$ by default.\nThis is a surprisingly good first-order approximation to the LWA beam, but it\ndoes not include any frequency dependence.   \n    J = \\begin{pmatrix}\n        \\sin({\\rm el})^{\\alpha/2} && 0 \\\\\n        0 && \\sin({\\rm el})^{\\alpha/2} \\\\\n    \\end{pmatrix}   Use  ttcal.jl ... --beam sine ...  to select the sine beam model (with $\\alpha = 1.6$)\nfrom the command line or use  beam = SineBeam(\u03b1)  from within a Julia script.", 
            "title": "Sine Beam"
        }, 
        {
            "location": "/beammodel/#lwa-memo-178-beam", 
            "text": "An even better approximation of the LWA beam comes from the LWA Memo Series. LWA Memo 178  by\nJayce Dowell does a parametric fit to the results of EM simulations of the\nantennas.  The dipole gain is modeled as   \n    p(\\theta) = \\left[1-\\left(\\frac{\\theta}{\\pi/2}\\right)^\\alpha\\right]\\cos^\\beta\\theta\n              + \\gamma\\left(\\frac{\\theta}{\\pi/2}\\right)\\cos^\\delta\\theta,   where $\\theta$ is the zenith angle, and $\\alpha$, $\\beta$, $\\gamma$, and $\\delta$ are\nparameters that were fit for in the E- and H-planes of the dipole.  Use  ttcal.jl ... --beam memo178 ...  to select the LWA Memo 178 beam model from the\ncommand line or use  beam = Memo178Beam()  from within a Julia script.", 
            "title": "LWA Memo 178 Beam"
        }, 
        {
            "location": "/ionosphere/", 
            "text": "The Ionosphere\n\u00b6\n\n\nNote that the \nTEC\n of the\nmodel ionosphere is currently hard coded to zero inside TTCal.\n\n\nRefraction\n\u00b6\n\n\nThe index of refraction of a cold, collisionless, and unmagnetized plasma is\n\n\n\n\n\n    n = \\sqrt{1 - \\frac{\\omega_p}{\\omega}},\n\n\n\n\n\nwhere $\\omega_p$ is the\n\nplasma frequency\n\nand $\\omega = 2\\pi\\nu$ is the angular frequency of the incident radiation.\n\n\nTTCal models the ionosphere as a single uniform spherical shell. That is it does not\naccount for the fact that ionosphere has multiple layers or that the density can\nvary within a layer. However with this simplification the refraction off the inner and\nouter edges of the ionosphere can be calculated with a simple ray tracer (see the\ndiagram below).\n\n\n\n\n\n\n\n\nFigure 1. An illustration of the ray tracing procedure used by TTCal to model ionospheric refraction.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbsorption\n\u00b6\n\n\nIonospheric absorption is not currently accounted for.", 
            "title": "The Ionosphere"
        }, 
        {
            "location": "/ionosphere/#the-ionosphere", 
            "text": "Note that the  TEC  of the\nmodel ionosphere is currently hard coded to zero inside TTCal.", 
            "title": "The Ionosphere"
        }, 
        {
            "location": "/ionosphere/#refraction", 
            "text": "The index of refraction of a cold, collisionless, and unmagnetized plasma is   \n    n = \\sqrt{1 - \\frac{\\omega_p}{\\omega}},   where $\\omega_p$ is the plasma frequency \nand $\\omega = 2\\pi\\nu$ is the angular frequency of the incident radiation.  TTCal models the ionosphere as a single uniform spherical shell. That is it does not\naccount for the fact that ionosphere has multiple layers or that the density can\nvary within a layer. However with this simplification the refraction off the inner and\nouter edges of the ionosphere can be calculated with a simple ray tracer (see the\ndiagram below).     Figure 1. An illustration of the ray tracing procedure used by TTCal to model ionospheric refraction.", 
            "title": "Refraction"
        }, 
        {
            "location": "/ionosphere/#absorption", 
            "text": "Ionospheric absorption is not currently accounted for.", 
            "title": "Absorption"
        }, 
        {
            "location": "/website/", 
            "text": "Building This Website\n\u00b6\n\n\nThis website is built using \nMkDocs\n and hosted\non \nGithub Pages\n. Building and deploying the\ndocumentation will require a little bit of setup.\n\n\n\n\nRun \npip install --user mkdocs\n to obtain MkDocs.\n\n\nRun \npip install --user python-markdown-math\n to obtain the markdown\n   extension that allows LaTeX-style math.\n\n\nEdit the documentation in the \ndocs/\n directory.\n\n\nRun \nmkdocs serve\n and navigate your web browser to\n   \nhttp://127.0.0.1:8000\n\n   to check that everything looks correct.\n\n\nCommit all your changes.\n\n\nRun \nmkdocs gh-deploy\n to deploy the new documentation to Github Pages.", 
            "title": "Building this Website"
        }, 
        {
            "location": "/website/#building-this-website", 
            "text": "This website is built using  MkDocs  and hosted\non  Github Pages . Building and deploying the\ndocumentation will require a little bit of setup.   Run  pip install --user mkdocs  to obtain MkDocs.  Run  pip install --user python-markdown-math  to obtain the markdown\n   extension that allows LaTeX-style math.  Edit the documentation in the  docs/  directory.  Run  mkdocs serve  and navigate your web browser to\n    http://127.0.0.1:8000 \n   to check that everything looks correct.  Commit all your changes.  Run  mkdocs gh-deploy  to deploy the new documentation to Github Pages.", 
            "title": "Building This Website"
        }
    ]
}